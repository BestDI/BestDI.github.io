<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mia&#39;s Home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-23T12:43:24.647Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Fingerprint浅析</title>
    <link href="http://yoursite.com/2018/04/21/Android-Fingerprint%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2018/04/21/Android-Fingerprint浅析/</id>
    <published>2018-04-21T15:24:00.000Z</published>
    <updated>2018-04-23T12:43:24.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android-Fingerprint浅析"><a href="#Android-Fingerprint浅析" class="headerlink" title="Android Fingerprint浅析"></a>Android Fingerprint浅析</h2><h3 id="一，Fingerprint总体架构图"><a href="#一，Fingerprint总体架构图" class="headerlink" title="一，Fingerprint总体架构图"></a>一，Fingerprint总体架构图</h3><p>Fingerprint表层模块架构如下，只涉及Application,Framework,Frigerprintd以及FingerprintHal，不包含指纹的认证驱动；</p><p><img src="/images/2018_0423/fp_communication.png" alt="Fp_communication"></p><a id="more"></a> <h3 id="二，Fingerprint-Framework初始化流程"><a href="#二，Fingerprint-Framework初始化流程" class="headerlink" title="二，Fingerprint Framework初始化流程"></a>二，Fingerprint Framework初始化流程</h3><p>2.1. 在Zygote初始化进程中，会启动各种Service，包括FingerprintServe；<br><code>FingerprintService</code>的启动在SystemServer.java的<code>startOtherService()</code>过程中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * API23</span></span><br><span class="line"><span class="comment"> * Starts a miscellaneous grab bag of stuff that has yet to be refactored</span></span><br><span class="line"><span class="comment"> * and organized.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// disableNonCoreServices -&gt; SystemProperties.getBoolean("config.disable_noncore", false);</span></span><br><span class="line"><span class="comment">// 配置项，是否加载非核心服务</span></span><br><span class="line">    <span class="keyword">if</span> (!disableNonCoreServices) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">"Media Router Service"</span>);</span><br><span class="line">            mediaRouter = <span class="keyword">new</span> MediaRouterService(context);</span><br><span class="line">            ServiceManager.addService(Context.MEDIA_ROUTER_SERVICE, mediaRouter);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            reportWtf(<span class="string">"starting MediaRouterService"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mSystemServiceManager.startService(TrustManagerService.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动FingerprintService</span></span><br><span class="line">        mSystemServiceManager.startService(FingerprintService.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">"BackgroundDexOptService"</span>);</span><br><span class="line">            BackgroundDexOptService.schedule(context, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            reportWtf(<span class="string">"starting BackgroundDexOptService"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Android N */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 启动FingerprintService</span></span><br><span class="line"><span class="comment">// FEATURE_FINGERPRINT = "android.hardware.fingerprint"</span></span><br><span class="line"><span class="comment">// mPackageManager.hasSystemFeature(&lt;fileName&gt;) &lt;- mAvailableFeatures(ArryayList) &lt;- SystemConfig去加载etc目录下的配置。</span></span><br><span class="line"><span class="keyword">if</span> (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FINGERPRINT)) &#123;</span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartFingerprintSensor"</span>);</span><br><span class="line">    mSystemServiceManager.startService(FingerprintService.class);</span><br><span class="line">    traceEnd();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2. 在Android N版本以上，加入了SystemFeature的判断，如果需要支持的话，需要在<code>framework/native/data/etc</code>目录下添加<code>android.hardware.fingerprint.xml</code>来支持该功能，mPackageManager.hasSystemFeature(<filename>)是最终通过获取配置来判断是否具有此功能。</filename></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- This is the standard set of features for a biometric fingerprint sensor. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">permissions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">feature</span> <span class="attr">name</span>=<span class="string">"android.hardware.fingerprint"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">permissions</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.3. 启动FingerprintService，并添加到ServiceManager中，</p><p><img src="/images/2018_0423/fp_service2.png" alt=""></p><blockquote><p>将FingerprintService添加到ServiceManager中后，在SystemServiceRegistry.java中静态代码块中注册服务的时候，可以从ServiceManager中获取FingerprintService的Binder对象，从而可以构造出FingerprintManager对象，这样app端就可以通过Context来获取FingerprintManager对象。 </p></blockquote><p><img src="/images/2018_0423/fp_service1.png" alt=""></p><blockquote><p>这样，app端通过Context获取FingerprintManager，通过调用FingerprintManager的接口来实现相应的功能，FingerprintManager转调FingerprintService中方法，FingerprintService负责管理整个注册，识别、删除指纹、检查权限等流程的逻辑，FingerprintService调用fingerprintd的接口，通过fingerprintd和FingerprintHal层进行通信。</p><p>在FingerprintService的getFingerprintDaemon方法中有如下步骤：<br>.1 获取fingerprintd<br>.2 向fingerprintd注册回调函数mDaemonCallback<br>.3 调用获取fingerprintd的openhal函数<br>.4 建立fingerprint文件系统节点，设置节点访问权限，调用fingerprintd的setActiveGroup，将路径传下去。此路径一半用来存储指纹模板的图片等</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IFingerprintDaemon <span class="title">getFingerprintDaemon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDaemon == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// .1 获取fingerprintd</span></span><br><span class="line">        mDaemon = IFingerprintDaemon.Stub.asInterface(ServiceManager.getService(FINGERPRINTD));</span><br><span class="line">        <span class="keyword">if</span> (mDaemon != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mDaemon.asBinder().linkToDeath(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// .2 向fingerprintd注册回调函数mDaemonCallback</span></span><br><span class="line">                mDaemon.init(mDaemonCallback);</span><br><span class="line">                <span class="comment">// .3 调用获取fingerprintd的openhal函数</span></span><br><span class="line">                mHalDeviceId = mDaemon.openHal();</span><br><span class="line">                <span class="comment">/* .4 建立fingerprint文件系统节点，设置节点访问权限，</span></span><br><span class="line"><span class="comment">                调用fingerprintd的setActiveGroup，</span></span><br><span class="line"><span class="comment">                将路径传下去。此路径一半用来存储指纹模板的图片等*/</span></span><br><span class="line">                <span class="keyword">if</span> (mHalDeviceId != <span class="number">0</span>) &#123;</span><br><span class="line">                    updateActiveGroup(ActivityManager.getCurrentUser());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Failed to open Fingerprint HAL!"</span>);</span><br><span class="line">                    mDaemon = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.e(TAG, <span class="string">"Failed to open fingeprintd HAL"</span>, e);</span><br><span class="line">                mDaemon = <span class="keyword">null</span>; <span class="comment">// try again later!</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"fingerprint service not available"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDaemon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>.1 FingerprintService在framework模块负责指纹的大部分逻辑，FingerprintService会在开机的时候初始化；<br>.2 application调用framework通过FingerprintManager接口即可实现；<br>.3 framework中FingerManager和FingerprintService的通信使用Binder机制实现，表现即使用aidl这个接口定义语言实现<br>.4 framework调往fingerprintd的同样属于Binder通信，两者分属于不同的进程。不过这部分跟java层Binder处理有点不一样，是java层往native层的调用。</p></blockquote><h3 id="三，Fingerprintd初始化"><a href="#三，Fingerprintd初始化" class="headerlink" title="三，Fingerprintd初始化"></a>三，Fingerprintd初始化</h3><p><img src="/images/2018_0423/fingerprintd_1.png" alt=""></p><blockquote><p>fingerprintd如果划分的比较细的话，可以分为四个部分：</p><ul><li><code>fingerprintd.cpp</code>“负责将fingerprintd加入到ServiceManager中，以便FingerprintService能够获取”</li><li><code>IFingerprintDaemon.h/IFingerprintDaemon.cpp</code>“负责java层到fingerprintd的Binder通信”</li><li><code>FingerprintDaemonProxy.h/FingerprintDaemonProxy.cpp</code>“负责fingerprintd和Fignerprint hal层的通信”</li><li><code>IFingerprintDaemonCallback.h/IFingerprintDaemonCallback.cpp</code>“负责将指纹的回调结果传给java层”</li></ul></blockquote><p>fingerprintd在init.rc有相应的开机启动脚本，所以一开机就会跑它的main函数。fingerprintd作为一个独立的进程运行，负责将Framework和Hal层的通信连接起来。</p><p><img src="/images/2018_0423/fpd_main.png" alt=""></p><p>fingerprintd 的main函数就是将fingerprintd添加到servicemanager中管理。然后开了一个线程，等待binder消息。</p><h3 id="四，IFingerprintDaemon是如何跟framework通信的"><a href="#四，IFingerprintDaemon是如何跟framework通信的" class="headerlink" title="四，IFingerprintDaemon是如何跟framework通信的"></a>四，IFingerprintDaemon是如何跟framework通信的</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> IFINGERPRINT_DAEMON_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IFINGERPRINT_DAEMON_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/IInterface.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/Parcel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IFingerprintDaemonCallback</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Abstract base class for native implementation of FingerprintService.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Note: This must be kept manually in sync with IFingerprintDaemon.aidl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IFingerprintDaemon</span> :</span> <span class="keyword">public</span> IInterface, <span class="keyword">public</span> IBinder::DeathRecipient &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum</span> &#123;</span><br><span class="line">           AUTHENTICATE = IBinder::FIRST_CALL_TRANSACTION + <span class="number">0</span>,</span><br><span class="line">           CANCEL_AUTHENTICATION = IBinder::FIRST_CALL_TRANSACTION + <span class="number">1</span>,</span><br><span class="line">           ENROLL = IBinder::FIRST_CALL_TRANSACTION + <span class="number">2</span>,</span><br><span class="line">           CANCEL_ENROLLMENT = IBinder::FIRST_CALL_TRANSACTION + <span class="number">3</span>,</span><br><span class="line">           PRE_ENROLL = IBinder::FIRST_CALL_TRANSACTION + <span class="number">4</span>,</span><br><span class="line">           REMOVE = IBinder::FIRST_CALL_TRANSACTION + <span class="number">5</span>,</span><br><span class="line">           GET_AUTHENTICATOR_ID = IBinder::FIRST_CALL_TRANSACTION + <span class="number">6</span>,</span><br><span class="line">           SET_ACTIVE_GROUP = IBinder::FIRST_CALL_TRANSACTION + <span class="number">7</span>,</span><br><span class="line">           OPEN_HAL = IBinder::FIRST_CALL_TRANSACTION + <span class="number">8</span>,</span><br><span class="line">           CLOSE_HAL = IBinder::FIRST_CALL_TRANSACTION + <span class="number">9</span>,</span><br><span class="line">           INIT = IBinder::FIRST_CALL_TRANSACTION + <span class="number">10</span>,</span><br><span class="line">           POST_ENROLL = IBinder::FIRST_CALL_TRANSACTION + <span class="number">11</span>,</span><br><span class="line">           ENUMERATE = IBinder::FIRST_CALL_TRANSACTION + <span class="number">12</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        IFingerprintDaemon() &#123; &#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~IFingerprintDaemon() &#123; &#125;</span><br><span class="line">        <span class="keyword">virtual</span> <span class="keyword">const</span> android::<span class="function">String16&amp; <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Binder interface methods</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> sp&lt;IFingerprintDaemonCallback&gt;&amp; callback)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> int32_t <span class="title">enroll</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* token, <span class="keyword">ssize_t</span> tokenLength, <span class="keyword">int32_t</span> groupId,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int32_t</span> timeout)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> uint64_t <span class="title">preEnroll</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> int32_t <span class="title">postEnroll</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> int32_t <span class="title">stopEnrollment</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> int32_t <span class="title">authenticate</span><span class="params">(<span class="keyword">uint64_t</span> sessionId, <span class="keyword">uint32_t</span> groupId)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> int32_t <span class="title">stopAuthentication</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> int32_t <span class="title">remove</span><span class="params">(<span class="keyword">int32_t</span> fingerId, <span class="keyword">int32_t</span> groupId)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> int32_t <span class="title">enumerate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> uint64_t <span class="title">getAuthenticatorId</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> int32_t <span class="title">setActiveGroup</span><span class="params">(<span class="keyword">int32_t</span> groupId, <span class="keyword">const</span> <span class="keyword">uint8_t</span>* path, <span class="keyword">ssize_t</span> pathLen)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> int64_t <span class="title">openHal</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> int32_t <span class="title">closeHal</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DECLARE_META_INTERFACE - C++ client interface not needed</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> android::String16 descriptor;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hal_notify_callback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">fingerprint_msg_t</span> *msg)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BnFingerprintDaemon</span>:</span> <span class="keyword">public</span> BnInterface&lt;IFingerprintDaemon&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> status_t <span class="title">onTransact</span><span class="params">(<span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       <span class="function"><span class="keyword">bool</span> <span class="title">checkPermission</span><span class="params">(<span class="keyword">const</span> String16&amp; permission)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace android</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// IFINGERPRINT_DAEMON_H_</span></span></span><br></pre></td></tr></table></figure><p>java层到fingerprintd的通信这里同样是采用binder方式，注意到上面IFingerprintDaemon.h NOTE，需要手动保证IFingerprintDaemon.h文件与IFingerprintDaemon.aidl文件一致，由于java层aidl文件编译时会自动编译成IFingerprintDaemon.java文件。</p><p>当添加接口来调用指纹底层暴露的接口，在IFingerprintDaemon.h文件中添加类似上面35行到68行的枚举，枚举的值需要与java层aidl自动生成的java文件中的枚举保持一致。另外还需要在上面68行处加上描述这些接口的纯虚函数（c++中的纯虚函数类似java的抽象方法，用于定义接口的规范，在C++中，一个具有纯虚函数的基类被称为抽象类）。<br>如下面截图对比，我们发现IFingerprintDaemon.cpp和java层aidl生成的IFingerprintDaemon.java在onTransact是基本一致的。这样我们也就明白了为什么上面说需要手动和IFingerprintDaemon.aidl保持同步了，这样方式类似我们平时在三方应用使用aidl文件，需要保持client端和server端aidl文件一致。</p><blockquote><p>可以看到onTransact有四个参数<br>code ， data ，replay ， flags<br>code 是一个整形的唯一标识，用于区分执行哪个方法，客户端会传递此参数，告诉服务端执行哪个方法<br>data客户端传递过来的参数<br>replay服务器返回回去的值<br>flags标明是否有返回值，0为有（双向），1为没有（单向）</p></blockquote><p><img src="/images/2018_0423/IFp_Daemon.png" alt=""></p><p>IFingerprintDaemon.aidl文件生成的IFingerprintDaemon.java文件 </p><p><img src="/images/2018_0423/IFp_java.png" alt=""></p><h3 id="五，fingerprintd进程是如何和Fingerprint-Hal层是如何传递数据的"><a href="#五，fingerprintd进程是如何和Fingerprint-Hal层是如何传递数据的" class="headerlink" title="五，fingerprintd进程是如何和Fingerprint Hal层是如何传递数据的"></a>五，fingerprintd进程是如何和Fingerprint Hal层是如何传递数据的</h3><blockquote><p>说到Hal层，即硬件抽象层，Android系统为HAL层中的模块接口定义了规范，所有工作于HAL的模块必须按照这个规范来编写模块接口，否则将无法正常访问硬件。 </p></blockquote><p><img src="/images/2018_0423/hal.png" alt=""></p><p>指纹的HAL层规范fingerprint.h在/hardware/libhardware/include/hardware/下可以看到。<br>我们注意到在fingerprint.h中定义了两个结构体，分别是fingerprint_device_t和fingerprint_module_t,如下图。</p><p><img src="/images/2018_0423/fp_h.png" alt=""></p><p>fingerprint_device_t结构体，用于描述指纹硬件设备；fingerprint_module_t结构体，用于描述指纹硬件模块。在FingerprintDaemonProxy.cpp就是通过拿到fingerprint_device_t这个结构体来和Fingerprint HAL层通信的。<br>当需要添加接口调用指纹底层时，在这个fingerprint.h中同样需要添加函数指针，然后通过FingerprintDaemonProxy.cpp中拿到这个fingerprint_device_t来调用fingerprint.h中定义的函数指针，也就相当于调用指纹HAL层。<br>我们重点看一下它的openHal（）函数。</p><p><img src="/images/2018_0423/fp_openHalNew.png" alt=""></p><p>openHal的方法这里主要看上面三个部分： </p><ol><li>根据名称获取指纹hal层模块。hw_module这个一般由指纹芯片厂商根据 fingerprint.h实现，hw_get_module是由HAL框架提供的一个公用的函数，这个函数的主要功能是根据模块ID(module_id)去查找注册在当前系统中与id对应的硬件对象，然后载入(load)其相应的HAL层驱动模块的*so文件。 </li><li>调用fingerprint_module_t的open函数 </li><li>向hal层注册消息回调函数，主要回调 注册指纹进度，识别结果，错误信息等等 </li><li>判断向hal层注册消息回调是否注册成功</li></ol><p>目前关于指纹的上层流程大致就到这儿，指纹底层就不怎么介绍了，术业有专攻，和专业做指纹的还是有不少差距。</p><h3 id="六，FingerprintManager相关阅读"><a href="#六，FingerprintManager相关阅读" class="headerlink" title="六，FingerprintManager相关阅读"></a>六，FingerprintManager相关阅读</h3><p>FingerprintManager中，具有一个Handler，用来分发Error/Help Msg，<br>其中，<code>IFingerprintServiceReceiver</code>用来接收FingerprintManagerService等从native层面识别成功的结果，<br>然后通过mHandler对象，进行结果的分发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Communication channel from the FingerprintService back to FingerprintManager.</span><br><span class="line"> * @hide</span><br><span class="line"> */</span><br><span class="line">oneway interface IFingerprintServiceReceiver &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2018_0423/fingerprintserviceReceiver.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Android-Fingerprint浅析&quot;&gt;&lt;a href=&quot;#Android-Fingerprint浅析&quot; class=&quot;headerlink&quot; title=&quot;Android Fingerprint浅析&quot;&gt;&lt;/a&gt;Android Fingerprint浅析&lt;/h2&gt;&lt;h3 id=&quot;一，Fingerprint总体架构图&quot;&gt;&lt;a href=&quot;#一，Fingerprint总体架构图&quot; class=&quot;headerlink&quot; title=&quot;一，Fingerprint总体架构图&quot;&gt;&lt;/a&gt;一，Fingerprint总体架构图&lt;/h3&gt;&lt;p&gt;Fingerprint表层模块架构如下，只涉及Application,Framework,Frigerprintd以及FingerprintHal，不包含指纹的认证驱动；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018_0423/fp_communication.png&quot; alt=&quot;Fp_communication&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>源码理解SharedPrefences</title>
    <link href="http://yoursite.com/2018/04/21/%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3SharedPrefences/"/>
    <id>http://yoursite.com/2018/04/21/源码理解SharedPrefences/</id>
    <published>2018-04-21T12:16:57.000Z</published>
    <updated>2018-04-21T13:07:45.747Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><blockquote><p><code>SharedPreferences</code>会从<code>shared_prefs</code>目录下的<code>&lt;name&gt;.xml</code>文件, 并将其以<code>get/put</code>的形式提供读写服务. 其中涉及到如下几个问题:</p><ol><li>如何从磁盘读取配置到内存</li><li><code>getXxx</code>如何从内存中获取配置</li><li>最终配置如何从内存回写到磁盘</li><li>多线程/多进程是否会有问题</li><li>以及最佳实践</li></ol></blockquote><a id="more"></a> <h3 id="二、前言总结"><a href="#二、前言总结" class="headerlink" title="二、前言总结"></a>二、前言总结</h3><blockquote><p><code>SharedPreferences</code>是线程安全的. 内部由大量<code>synchronized</code>关键字保障,<br><code>SharedPreferences</code>不是进程安全的;</p><p>初始化SP对象时，<code>getSharedPreferences</code>会读取磁盘文件, 后续的<code>getSharedPreferences</code>获取<code>SP</code>会从内存缓存中获取. 如果第一次调用<code>getSharedPreferences</code>时还没从磁盘加载完毕就调用<code>getXxx/putXxx</code>, 则<code>getXxx/putXxx</code>操作会卡主, 直到数据从磁盘加载完毕后返回<br>所有的<code>getXxx</code>都是从内存中取的数据；</p><p><code>apply</code>是同步回写内存, 然后把异步回写磁盘的任务放到一个单线程的队列中等待调度.<code>commit</code>和前者一样, 只不过要等待异步磁盘任务结束后才返回;</p><p><code>MODE_MULTI_PROCESS</code>是在每次<code>getSharedPreferences</code>时检查磁盘上配置文件上次修改时间和文件大小, 一旦所有修改则会重新从磁盘加载文件. 所以并不能保证多进程数据的实时同步,<br>从<strong>Android N</strong>开始, 不再支持<code>MODE_WORLD_READABLE &amp; MODE_WORLD_WRITEABLE</code>一旦指定, 会抛异常。</p></blockquote><h3 id="三、最佳实践"><a href="#三、最佳实践" class="headerlink" title="三、最佳实践"></a>三、最佳实践</h3><blockquote><p>不要多进程使用, 很小几率会造成数据全部丢失, 现象是配置文件被删除;<br>不要依赖<code>MODE_MULTI_PROCESS</code>. 这个标记就像<code>MODE_WORLD_READABLE/MODE_WORLD_WRITEABLE</code>未来会被废弃;<br>每次<code>apply / commit</code>都会把全部的数据一次性写入磁盘, 所以单个的配置文件不应该过大, 影响整体性能.</p></blockquote><h3 id="四、源码全面分析"><a href="#四、源码全面分析" class="headerlink" title="四、源码全面分析"></a>四、源码全面分析</h3><h4 id="4-1-SharedPreferences-对象的获取"><a href="#4-1-SharedPreferences-对象的获取" class="headerlink" title="4.1 SharedPreferences 对象的获取"></a>4.1 SharedPreferences 对象的获取</h4><p>常见的获取方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PreferenceManager#getDefaultSharedPreferences()</span><br><span class="line">ContextImpl#getSharedPreferences()</span><br></pre></td></tr></table></figure></p><p>以上述<code>PreferenceManager#getDefaultSharedPreferences()</code>为例来看看源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// PreferenceManager.java</span><br><span class="line">public static SharedPreferences getDefaultSharedPreferences(Context context) &#123;</span><br><span class="line">    return context.getSharedPreferences(getDefaultSharedPreferencesName(context),</span><br><span class="line">            getDefaultSharedPreferencesMode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实上述的获取方式中, 最终都是调用到了<code>ContextImpl#getSharedPreferences()</code>源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// ContextImpl.java</span><br><span class="line">public SharedPreferences getSharedPreferences(String name, int mode) &#123;</span><br><span class="line">    SharedPreferencesImpl sp;</span><br><span class="line">    synchronized (ContextImpl.class) &#123; // 线程同步</span><br><span class="line">        if (sSharedPrefs == null) &#123;</span><br><span class="line">            sSharedPrefs = new ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        final String packageName = getPackageName();</span><br><span class="line">        ArrayMap&lt;String, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefs.get(packageName);</span><br><span class="line">        if (packagePrefs == null) &#123;</span><br><span class="line">            packagePrefs = new ArrayMap&lt;String, SharedPreferencesImpl&gt;();</span><br><span class="line">            sSharedPrefs.put(packageName, packagePrefs);</span><br><span class="line">        &#125;</span><br><span class="line">        // At least one application in the world actually passes in a null</span><br><span class="line">        // name.  This happened to work because when we generated the file name</span><br><span class="line">        // we would stringify it to &quot;null.xml&quot;.  Nice.</span><br><span class="line">        if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</span><br><span class="line">                Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            if (name == null) &#123;</span><br><span class="line">                name = &quot;null&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 从缓存中获取sp对象，sp是null时才会去创建</span><br><span class="line">        sp = packagePrefs.get(name);</span><br><span class="line">        if (sp == null) &#123;</span><br><span class="line">            File prefsFile = getSharedPrefsFile(name); // data/data/&lt;packageName&gt;/shared_prefs/&lt;name&gt;.xml</span><br><span class="line">            sp = new SharedPreferencesImpl(prefsFile, mode);</span><br><span class="line">            packagePrefs.put(name, sp);</span><br><span class="line">            return sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||</span><br><span class="line">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        // If somebody else (some other process) changed the prefs</span><br><span class="line">        // file behind our back, we reload it.  This has been the</span><br><span class="line">        // historical (if undocumented) behavior.</span><br><span class="line">        sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">    &#125;</span><br><span class="line">    return sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见<code>Android SDK</code>是先取了缓存,如果缓存未命中,才构造对象.<br>也就是说, 多次<code>getSharedPreferences</code>几乎是没有代价的.<br>同时, 实例的构造被<code>synchronized</code>关键字包裹, 因此构造过程是多线程安全的.</p><h4 id="4-2-SharedPreferences-的构造"><a href="#4-2-SharedPreferences-的构造" class="headerlink" title="4.2 SharedPreferences 的构造"></a>4.2 SharedPreferences 的构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SharedPreferencesImpl.java</span><br><span class="line">SharedPreferencesImpl(File file, int mode) &#123;</span><br><span class="line">    mFile = file; //代表我们磁盘上的配置文件</span><br><span class="line">    mBackupFile = makeBackupFile(file); // 备份文件, 用户写入失败时进行恢复. 其路径是 mFile 加后缀 ‘.bak’</span><br><span class="line">    mMode = mode;</span><br><span class="line">    mLoaded = false;</span><br><span class="line">    mMap = null; // 用于在内存中缓存我们的配置数据, 也就是 getXxx 数据的来源</span><br><span class="line">    startLoadFromDisk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步查看<code>startLoadFromDisk</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SharedPreferencesImpl.java</span><br><span class="line">private void startLoadFromDisk() &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        mLoaded = false; // 初始化结束的标记，在get/put中能看到</span><br><span class="line">    &#125;</span><br><span class="line">    new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (SharedPreferencesImpl.this) &#123;</span><br><span class="line">                loadFromDiskLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处开启线程从文件读取, 其源码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// SharedPreferencesImpl.java</span><br><span class="line">private void loadFromDisk() &#123;</span><br><span class="line">    synchronized (SharedPreferencesImpl.this) &#123;</span><br><span class="line">        if (mLoaded) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 备份文件对原文件进行覆盖；</span><br><span class="line">// 读写之前创建，读写成功删除。</span><br><span class="line">        if (mBackupFile.exists()) &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">            mBackupFile.renameTo(mFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... 略去无关代码 ...</span><br><span class="line"></span><br><span class="line">    str = new BufferedInputStream(</span><br><span class="line">            new FileInputStream(mFile), 16*1024);</span><br><span class="line">    // 使用XMLPullParser的方式去解析文件</span><br><span class="line">    map = XmlUtils.readMapXml(str);</span><br><span class="line"></span><br><span class="line">    synchronized (SharedPreferencesImpl.this) &#123;</span><br><span class="line">        mLoaded = true;// 关键标记,修改状态</span><br><span class="line">        if (map != null) &#123;</span><br><span class="line">            mMap = map;</span><br><span class="line">            mStatTimestamp = stat.st_mtime;</span><br><span class="line">            mStatSize = stat.st_size;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mMap = new HashMap&lt;String, Object&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        // 唤醒等待的其他线程，例如在读写之前会存在一个等待加载的过程</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadFromDisk 这个函数很关键. 它就是实际从磁盘读取配置文件的函数. 可见, 它做了如下几件事:</p><ol><li>如果有 ‘备份’ 文件, 则直接使用备份文件回滚覆盖原文件(读写之前创建，读写成果即删除的特性).</li><li>把配置从磁盘读取到内存的并保存在<code>mMap</code>字段中(看代码最后 mMap = map)</li><li>标记读取完成, 这个字段后面<code>awaitLoadedLocked</code>会用到. 记录读取文件的时间, 后面<code>MODE_MULTI_PROCESS</code>中会用到</li><li><code>notifyAll</code>通知已经读取完毕, 激活所有等待加载的其他线程.</li></ol><p><img src="/images/2018_0421/sharedPreferences.png" alt=""></p><h4 id="4-3-getXxx-的流程"><a href="#4-3-getXxx-的流程" class="headerlink" title="4.3 getXxx 的流程"></a>4.3 getXxx 的流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SharedPreferencesImpl.java</span><br><span class="line">public String getString(String key, @Nullable String defValue) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">        String v = (String)mMap.get(key);</span><br><span class="line">        return v != null ? v : defValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见, 所有的<code>get</code>操作都是线程安全的. 并且<code>get</code>仅仅是从内存中<code>(mMap)</code>获取数据, 所以无性能问题.</p><p>考虑到 配置文件的加载 是在单独的线程中异步进行的(参考 ‘SharedPreferences 的构造’), 所以这里的 awaitLoadedLocked 是在等待配置文件加载完毕. 也就是说如果我们第一次构造 SharedPreferences 后就立刻调用 getXxx 方法, 很有可能读取配置文件的线程还未完成, 所以这里要等待该线程做完相应的加载工作. 来看看 awaitLoadedLocked 的源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SharedPreferencesImpl.java</span><br><span class="line">private void awaitLoadedLocked() &#123;</span><br><span class="line">    if (!mLoaded) &#123;</span><br><span class="line">        // Raise an explicit StrictMode onReadFromDisk for this</span><br><span class="line">        // thread, since the real read will be in a different</span><br><span class="line">        // thread and otherwise ignored by StrictMode.</span><br><span class="line">        BlockGuard.getThreadPolicy().onReadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line">    while (!mLoaded) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; catch (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显, 如果加载还未完成(mLoaded == false), <code>getXxx</code>会卡在<code>awaitLoadedLocked</code>, 一旦加载配置文件的线程工作完毕, 则这个加载线程会通过<code>notifyAll</code>会通知所有在 awaitLoadedLocked 中等待的线程, getXxx 就能够返回了. 不过大部分情况下, mLoaded == true. 这样的话 awaitLoadedLocked 会直接返回</p><h4 id="4-4-putXxx-的流程"><a href="#4-4-putXxx-的流程" class="headerlink" title="4.4 putXxx 的流程"></a>4.4 putXxx 的流程</h4><p>set 比 get 稍微麻烦一点儿, 因为涉及到 Editor 和 MemoryCommitResult 对象</p><p>先来看看 edit() 方法的实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SharedPreferencesImpl.java</span><br><span class="line">public Editor edit() &#123;</span><br><span class="line">    // TODO: remove the need to call awaitLoadedLocked() when</span><br><span class="line">    // requesting an editor.  will require some work on the</span><br><span class="line">    // Editor, but then we should be able to do:</span><br><span class="line">    //</span><br><span class="line">    //      context.getSharedPreferences(..).edit().putString(..).apply()</span><br><span class="line">    //</span><br><span class="line">    // ... all without blocking.</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new EditorImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-Editor"><a href="#4-5-Editor" class="headerlink" title="4.5 Editor"></a>4.5 Editor</h4><p>Editor 没有构造函数, 只有两个属性被初始化:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SharedPreferencesImpl.java</span><br><span class="line">public final class EditorImpl implements Editor &#123;</span><br><span class="line">    private final Map&lt;String, Object&gt; mModified = Maps.newHashMap();</span><br><span class="line">    private boolean mClear = false;</span><br><span class="line"></span><br><span class="line">    ... 略去方法定义 ...</span><br><span class="line">    public Editor putString(String key, @Nullable String value) &#123; ... &#125;</span><br><span class="line">    public boolean commit() &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mModified 是我们每次 putXxx 后所改变的配置项<br>mClear 标识要清空配置项, 但是只清了 SharedPreferences.mMap. 所以不要写这样的愚蠢代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sharedPreferences.edit()</span><br><span class="line">        .putBoolean(&amp;quot;foo&amp;quot;, true)        // foo 无法被 clear 掉</span><br><span class="line">        .clear()</span><br><span class="line">        .putBoolean(&amp;quot;bar&amp;quot;, true)</span><br><span class="line">        .commit()</span><br></pre></td></tr></table></figure><p>edit() 会保障配置已从磁盘读取完毕, 然后仅仅创建了一个对象. 接下来看看 putXxx 的真身:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SharedPreferencesImpl.java</span><br><span class="line">public Editor putString(String key, @Nullable String value) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        mModified.put(key, value);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单, 仅仅是把我们设置的配置项放到了 mModified 属性里保存. 等到 apply 或者 commit 的时候回写到内存和磁盘. 咱们分别来看看</p><h4 id="4-6-apply"><a href="#4-6-apply" class="headerlink" title="4.6 apply"></a>4.6 apply</h4><p>apply 是各种 ‘最佳实践’ 推荐的方式, 那么它到底是怎么异步工作的呢? 我们来看个究竟:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// SharedPreferencesImpl.java</span><br><span class="line">public void apply() &#123;</span><br><span class="line">    final MemoryCommitResult mcr = commitToMemory(); // 将修改放入内存中，包括放入mMap</span><br><span class="line">    final Runnable awaitCommit = new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    mcr.writtenToDiskLatch.await();</span><br><span class="line">                &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    QueuedWork.add(awaitCommit);</span><br><span class="line"></span><br><span class="line">    Runnable postWriteRunnable = new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.remove(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line"></span><br><span class="line">    // Okay to notify the listeners before it&amp;#039;s hit disk</span><br><span class="line">    // because the listeners should always get the same</span><br><span class="line">    // SharedPreferences instance back, which has the</span><br><span class="line">    // changes reflected in memory.</span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出大致的脉络:</p><ol><li>commitToMemory 应该是把修改的配置项回写到内存</li><li>QueuedWork.add(awaitCommit) 貌似没什么卵用</li><li>SharedPreferencesImpl.this.enqueueDiskWrite 把配置项加入到一个异步队列中, 等待调度</li></ol><p>我们来看看 commitToMemory 的实现(略去大量无关代码):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// SharedPreferencesImpl.java</span><br><span class="line">private MemoryCommitResult commitToMemory() &#123;</span><br><span class="line">    MemoryCommitResult mcr = new MemoryCommitResult();</span><br><span class="line">    synchronized (SharedPreferencesImpl.this) &#123;</span><br><span class="line"></span><br><span class="line">        ... 略去无关 ...</span><br><span class="line"></span><br><span class="line">        mcr.mapToWriteToDisk = mMap;</span><br><span class="line">        mDiskWritesInFlight++;</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            for (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;</span><br><span class="line">                String k = e.getKey();</span><br><span class="line">                Object v = e.getValue();</span><br><span class="line">                // &amp;quot;this&amp;quot; is the magic value for a removal mutation. In addition,</span><br><span class="line">                // setting a value to &amp;quot;null&amp;quot; for a given key is specified to be</span><br><span class="line">                // equivalent to calling remove on that key.</span><br><span class="line">                if (v == this || v == null) &#123;</span><br><span class="line">                    mMap.remove(k);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mMap.put(k, v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mModified.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return mcr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结来说:</p><ol><li>把 Editor.mModified 中的配置项回写到 SharedPreferences.mMap 中, 完成了内存的同步;</li><li>把 SharedPreferences.mMap 保存在了 mcr.mapToWriteToDisk 中. 而后者就是即将要回写到磁盘的数据源;</li></ol><p>我们再来回头看看 apply 方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SharedPreferencesImpl.java</span><br><span class="line">public void apply() &#123;</span><br><span class="line">    final MemoryCommitResult mcr = commitToMemory();</span><br><span class="line"></span><br><span class="line">    ... 略无关 ...</span><br><span class="line"></span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>commitToMemory 完成了内存的同步回写<br>enqueueDiskWrite 完成了硬盘的异步回写, 我们接下来具体看看<br>enqueueDiskWrite</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SharedPreferencesImpl.java</span><br><span class="line">private void enqueueDiskWrite(final MemoryCommitResult mcr,</span><br><span class="line">                                final Runnable postWriteRunnable) &#123;</span><br><span class="line">    final Runnable writeToDiskRunnable = new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (mWritingToDiskLock) &#123;</span><br><span class="line">                    writeToFile(mcr);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QueuedWork.singleThreadExecutor 实际上就是 ‘一个线程的线程池’, 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// QueuedWork.java</span><br><span class="line">public static ExecutorService singleThreadExecutor() &#123;</span><br><span class="line">    synchronized (QueuedWork.class) &#123;</span><br><span class="line">        if (sSingleThreadExecutor == null) &#123;</span><br><span class="line">            // TODO: can we give this single thread a thread name?</span><br><span class="line">            sSingleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line">        &#125;</span><br><span class="line">        return sSingleThreadExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到 enqueueDiskWrite 中, 这里还有一个重要的函数叫做 writeToFile:</p><p>writeToFile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SharedPreferencesImpl.java</span><br><span class="line">private void writeToFile(MemoryCommitResult mcr) &#123;</span><br><span class="line">    // Rename the current file so it may be used as a backup during the next read</span><br><span class="line">    if (mFile.exists()) &#123;</span><br><span class="line">        if (!mBackupFile.exists()) &#123;</span><br><span class="line">            if (!mFile.renameTo(mBackupFile)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Attempt to write the file, delete the backup and return true as atomically as</span><br><span class="line">    // possible.  If any exception occurs, delete the new file; next time we will restore</span><br><span class="line">    // from the backup.</span><br><span class="line">    try &#123;</span><br><span class="line">        FileOutputStream str = createFileOutputStream(mFile);</span><br><span class="line">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</span><br><span class="line">        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);</span><br><span class="line">        try &#123;</span><br><span class="line">            final StructStat stat = Os.stat(mFile.getPath());</span><br><span class="line">                mStatTimestamp = stat.st_mtime;</span><br><span class="line">                mStatSize = stat.st_size;</span><br><span class="line">        &#125;</span><br><span class="line">        // Writing was successful, delete the backup file if there is one.</span><br><span class="line">        mBackupFile.delete();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Clean up an unsuccessfully written file</span><br><span class="line">    mFile.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码大致分为三个过程:</p><ol><li>先把已存在的老的配置文件重命名(加 ‘.bak’ 后缀), 然后删除老的配置文件. 这相当于做了灾备</li><li>向 mFile 中一次性写入所有配置项. 即 mcr.mapToWriteToDisk(这就是 commitToMemory 所说的保存了所有配置项的字段) 一次性写入到磁盘. 如果写入成功则删除灾备文件, 同时记录了这次同步的时间</li><li>如果上述过程 [2] 失败, 则删除这个半成品的配置文件</li></ol><p>好了, 我们来总结一下 apply:</p><ol><li>通过 commitToMemory 将修改的配置项同步回写到内存 SharedPreferences.mMap 中. 此时, 任何的 getXxx 都可以获取到最新数据了</li><li>通过 enqueueDiskWrite 调用 writeToFile 将所有配置项一次性异步回写到磁盘. 这是一个单线程的线程池</li></ol><p><img src="/images/2018_0421/apply.png" alt=""></p><h4 id="4-7-commit"><a href="#4-7-commit" class="headerlink" title="4.7 commit"></a>4.7 commit</h4><p>相对于apply的代码，commit的明了很多：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SharedPreferencesImpl.java</span><br><span class="line">public boolean commit() &#123;</span><br><span class="line">    MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(</span><br><span class="line">        mcr, null /* sync write on this thread okay */);</span><br><span class="line">    try &#123;</span><br><span class="line">        mcr.writtenToDiskLatch.await();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">    return mcr.writeToDiskResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2018_0421/commit.png" alt=""></p><p>apply/commit的异同可以看到 ‘等待异步任务返回’ 的线, 对比 apply 的时序图, 一眼就看出差别</p><p><code>registerOnSharedPreferenceChangeListener</code></p><p>最后需要提一下的就是 listener:</p><ul><li>对于 apply, listener 回调时内存已经完成同步, 但是异步磁盘任务不保证是否完成</li><li>对于 commit, listener 回调时内存和磁盘都已经同步完毕</li></ul><h4 id="4-8-各种标记的作用"><a href="#4-8-各种标记的作用" class="headerlink" title="4.8 各种标记的作用"></a>4.8 各种标记的作用</h4><ul><li><p><strong>MODE_PRIVATE/MODE_WORLD_READABLE/MODE_WORLD_WRITEABLE</strong>:<br>指的是, 在保存文件的时候设置的文件属性. PRIVATE 就只有自己和所属组的读写权限, READABLE/WRITEABLE 是对 other 用户和组的读写权限. 主要源码位于: FileUtils.setPermissions</p></li><li><p><strong>MODE_MULTI_PROCESS</strong>:<br>阅读过本文的话你会知道, 一个 prefs 实例通常有两种获得途径, 一个是第一次被 new 创建出来的, 这种方式会实际的读取磁盘文件. 还一种是后续从缓存(sSharedPrefsCache) 中取出来了.<br>而这个标记的意思就是: 使用 getSharedPrefercences 获取实例时, 无论是从磁盘读文件构造对象还是从缓存获取, 都会检查实例的 ‘内存中保存的时间’ 和 ‘磁盘上文件的最后修改时间’, 如果内存中保存的时间和磁盘上文件的最后修改时间, 则重新加载文件. 可以认为如果实例是从磁盘读取构造出来的, 那么他的 ‘内存中保存的时间’ 和 ‘文件的最后修改时间’ 一定是一样的, 而从缓存中来的实例就不一样了, 因为它可能很早就被创建(那个时候就已经读取了磁盘的文件并记录了当时文件的最后修改时间), 在随后的期间里其他进程很可能修改过磁盘上的配置文件导致最后修改时间变化, 这时候当我们从缓存中再次获取这个实例的时候, 系统会帮你检查这个文件在这段时间是否被修改过(‘内存中保存的时间’ 和 ‘磁盘上文件的最后修改时间’ 是否一致), 如果被修改过, 则重新从磁盘读取配置文件, 保证获取实例的内容是最新的.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;SharedPreferences&lt;/code&gt;会从&lt;code&gt;shared_prefs&lt;/code&gt;目录下的&lt;code&gt;&amp;lt;name&amp;gt;.xml&lt;/code&gt;文件, 并将其以&lt;code&gt;get/put&lt;/code&gt;的形式提供读写服务. 其中涉及到如下几个问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何从磁盘读取配置到内存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getXxx&lt;/code&gt;如何从内存中获取配置&lt;/li&gt;
&lt;li&gt;最终配置如何从内存回写到磁盘&lt;/li&gt;
&lt;li&gt;多线程/多进程是否会有问题&lt;/li&gt;
&lt;li&gt;以及最佳实践&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vysor Pro破解</title>
    <link href="http://yoursite.com/2018/04/14/Vysor-Pro%E7%A0%B4%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/04/14/Vysor-Pro破解/</id>
    <published>2018-04-14T03:21:36.000Z</published>
    <updated>2018-04-14T03:41:43.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vysor-Pro破解"><a href="#Vysor-Pro破解" class="headerlink" title="Vysor Pro破解"></a>Vysor Pro破解</h2><blockquote><p>下载官网 <strong><a href="https://www.vysor.io/" target="_blank" rel="noopener">Vysor</a></strong></p><p>文中在WIN10环境下针对<code>chrome插件版本的Vysor</code>进行的破解</p></blockquote><a id="more"></a> <h3 id="破解Vysor-Pro"><a href="#破解Vysor-Pro" class="headerlink" title="破解Vysor Pro"></a>破解Vysor Pro</h3><ol><li>确保你成功安装Chrome且安装了此插件并启动过一次；</li><li>打开Chrome拓展程序-&gt;启用开发者模式，找到Vysor即可看到ID 记住这个id；</li></ol><p><img src="/images/2018_0414/chrome_vysor.png" alt=""></p><ol><li>打开<code>Vysor</code>本地文件<code>uglify.js</code>，具体路径如下：<code>C:\Users\当前用户名\AppData\Local\Google\Chrome\UserData\Default\Extensions\Vysor_Id\1.9.0/uglify.js</code></li><li>打开<code>uglify.js</code>之后，可以使用进行格式化<a href="https://www.json.cn/" target="_blank" rel="noopener">www.json.cn</a></li><li>搜索关键字<br><code>Vysor subscription is active. Thank you for your support</code></li><li>按照图示进行文件修改，并保存重启Vysor即可</li></ol><p><img src="/images/2018_0414/vysor_modify.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Vysor-Pro破解&quot;&gt;&lt;a href=&quot;#Vysor-Pro破解&quot; class=&quot;headerlink&quot; title=&quot;Vysor Pro破解&quot;&gt;&lt;/a&gt;Vysor Pro破解&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;下载官网 &lt;strong&gt;&lt;a href=&quot;https://www.vysor.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vysor&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文中在WIN10环境下针对&lt;code&gt;chrome插件版本的Vysor&lt;/code&gt;进行的破解&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="tools" scheme="http://yoursite.com/categories/tools/"/>
    
    
      <category term="Vysor" scheme="http://yoursite.com/tags/Vysor/"/>
    
  </entry>
  
  <entry>
    <title>AndFix原理及源码解析</title>
    <link href="http://yoursite.com/2018/04/01/AndFix%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/04/01/AndFix原理及源码解析/</id>
    <published>2018-04-01T15:10:15.000Z</published>
    <updated>2018-04-01T15:17:20.721Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><blockquote><p><a href="https://github.com/alibaba/AndFix" target="_blank" rel="noopener"><strong>AndFix</strong></a> 是阿里系的一个轻量级热修复，热更新框架，只支持简单的method修改，没有res修复等臃肿功能。具体的实现是通过native进行原函数的指针替换，具有一次修复，持续有效的特性（当然是不清除app所有数据前提下）。<code>AndFix has a native method art_replaceMethod in ART or dalvik_replaceMethod in Dalvik.</code></p></blockquote><p><img src="/images/2018_0401/principle.png" alt="方法替换原理"></p><a id="more"></a> <h4 id="二、使用Demo，及步骤列举"><a href="#二、使用Demo，及步骤列举" class="headerlink" title="二、使用Demo，及步骤列举"></a>二、使用Demo，及步骤列举</h4><blockquote><p>AndFix的具体修复流程正如官方文档所描述的，是基于相同版本进行的修复，而AndFix所提供的apkpatch.bat是分析和对比，通过指定对应的apk、keystore生成.patch文件（热修复所需要的，可以通过网络路径存放等等方式）</p></blockquote><p><img src="/images/2018_0401/process.png" alt="Alt text"></p><h5 id="1-使用demo"><a href="#1-使用demo" class="headerlink" title="1. 使用demo"></a>1. 使用demo</h5><blockquote><ol><li><p>初始化PatchManager</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">patchManager = new PatchManager(context);</span><br><span class="line">patchManager.init(appversion);//current version</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li><li><p>加载patch文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patchManager.loadPatch();// You should load patch as early as possible, generally, in the initialization phase of your application(such as Application.onCreate()).</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li><li><p>Add patch,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patchManager.addPatch(path);//path of the patch file that was downloaded</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h5 id="2-步骤列举"><a href="#2-步骤列举" class="headerlink" title="2. 步骤列举"></a>2. 步骤列举</h5><blockquote><ol><li><p>.patch文件分析，使用apkpatch.bat生成的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── 1.txt</span><br><span class="line">├── diff.dex</span><br><span class="line">├── out.apatch</span><br><span class="line">└── smali</span><br><span class="line">    └── com</span><br><span class="line">        └── tong</span><br><span class="line">            └── android_hot_fix</span><br><span class="line">                └── CalcUtils_CF.smali</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li><li><p>其中，.patch文件其实是个压缩包，其中包含的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; .</span><br><span class="line">├── classes.dex // 具体的修复class</span><br><span class="line">└── META-INF</span><br><span class="line">    ├── CERT.RSA // 签名整数</span><br><span class="line">    ├── CERT.SF // 证书相关INFO</span><br><span class="line">    ├── MANIFEST.MF // Manifest相关</span><br><span class="line">    └── PATCH.MF // patch生成相关信息</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li><li><p>dex-&gt;jar classes.dex之后，可以看到生成的class文件中，会有<code>@MethodReplace(clazz=&quot;com.tong.android_hot_fix.CalcUtils&quot;, method=&quot;calc&quot;)</code> 这种注解，注解的作用是在method加载的时候，使用此标记去判断需要替换的方法，深层次是用natvie层的C进行指针映射到修复后函数。</p></li></ol></blockquote><h4 id="三、源码解析"><a href="#三、源码解析" class="headerlink" title="三、源码解析"></a>三、源码解析</h4><p>1、 初始化PatchManager对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public PatchManager(Context context) &#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mAndFixManager = new AndFixManager(mContext);</span><br><span class="line">    // mPatchDir是.patch的复制保存路径，AndFix是从此目录去查找.patch，此目录为../packageName/file/aptch</span><br><span class="line">    mPatchDir = new File(mContext.getFilesDir(), DIR);</span><br><span class="line">    mPatchs = new ConcurrentSkipListSet&lt;Patch&gt;();</span><br><span class="line">    mLoaders = new ConcurrentHashMap&lt;String, ClassLoader&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>初始化PatchManager过程中，初始化了AndFixManager，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public AndFixManager(Context context) &#123;</span><br><span class="line">mContext = context;</span><br><span class="line">mSupport = Compat.isSupport();// 去判断当前设备是否支持热修复功能</span><br><span class="line">if (mSupport) &#123;</span><br><span class="line">// SecurityChecker主要做.patch签名验证等功能</span><br><span class="line">mSecurityChecker = new SecurityChecker(mContext);</span><br><span class="line">mOptDir = new File(mContext.getFilesDir(), DIR);</span><br><span class="line">if (!mOptDir.exists() &amp;&amp; !mOptDir.mkdirs()) &#123;// make directory fail</span><br><span class="line">mSupport = false;</span><br><span class="line">Log.e(TAG, &quot;opt dir create error.&quot;);</span><br><span class="line">&#125; else if (!mOptDir.isDirectory()) &#123;// not directory</span><br><span class="line">mOptDir.delete();</span><br><span class="line">mSupport = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、 <code>patchManager.loadPatch()</code>加载.patch文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * load patch,call when application start</span><br><span class="line"> */</span><br><span class="line">public void loadPatch() &#123;</span><br><span class="line">    mLoaders.put(&quot;*&quot;, mContext.getClassLoader());// wildcard</span><br><span class="line">    Set&lt;String&gt; patchNames;</span><br><span class="line">    List&lt;String&gt; classes;</span><br><span class="line">    for (Patch patch : mPatchs) &#123;</span><br><span class="line">        patchNames = patch.getPatchNames();</span><br><span class="line">        for (String patchName : patchNames) &#123;</span><br><span class="line">            classes = patch.getClasses(patchName);</span><br><span class="line">            // 调用AndFixManager.fix()</span><br><span class="line">            mAndFixManager.fix(patch.getFile(), mContext.getClassLoader(),</span><br><span class="line">                    classes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以跟随看到AndFixManager的方法实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * fix</span><br><span class="line"> * </span><br><span class="line"> * @param file</span><br><span class="line"> *            patch file</span><br><span class="line"> * @param classLoader</span><br><span class="line"> *            classloader of class that will be fixed</span><br><span class="line"> * @param classes</span><br><span class="line"> *            classes will be fixed</span><br><span class="line"> */</span><br><span class="line">public synchronized void fix(File file, ClassLoader classLoader,</span><br><span class="line">List&lt;String&gt; classes) &#123;</span><br><span class="line">if (!mSupport) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">// 进行Security验证</span><br><span class="line">if (!mSecurityChecker.verifyApk(file)) &#123;// security check fail</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">// 1.从file/patch目录下读取.patch文件</span><br><span class="line">File optfile = new File(mOptDir, file.getName());</span><br><span class="line">boolean saveFingerprint = true;</span><br><span class="line">if (optfile.exists()) &#123;</span><br><span class="line">// need to verify fingerprint when the optimize file exist,</span><br><span class="line">// prevent someone attack on jailbreak device with</span><br><span class="line">// Vulnerability-Parasyte.</span><br><span class="line">// btw:exaggerated android Vulnerability-Parasyte</span><br><span class="line">// http://secauo.com/Exaggerated-Android-Vulnerability-Parasyte.html</span><br><span class="line">if (mSecurityChecker.verifyOpt(optfile)) &#123;</span><br><span class="line">saveFingerprint = false;</span><br><span class="line">&#125; else if (!optfile.delete()) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 加载其压缩包中的.dex文件</span><br><span class="line">final DexFile dexFile = DexFile.loadDex(file.getAbsolutePath(),</span><br><span class="line">optfile.getAbsolutePath(), Context.MODE_PRIVATE);</span><br><span class="line">if (saveFingerprint) &#123;</span><br><span class="line">mSecurityChecker.saveOptSig(optfile);</span><br><span class="line">&#125;</span><br><span class="line">ClassLoader patchClassLoader = new ClassLoader(classLoader) &#123;</span><br><span class="line">@Override</span><br><span class="line">protected Class&lt;?&gt; findClass(String className)</span><br><span class="line">throws ClassNotFoundException &#123;</span><br><span class="line">Class&lt;?&gt; clazz = dexFile.loadClass(className, this);</span><br><span class="line">if (clazz == null</span><br><span class="line">&amp;&amp; className.startsWith(&quot;com.alipay.euler.andfix&quot;)) &#123;</span><br><span class="line">return Class.forName(className);// annotation’s class</span><br><span class="line">// not found</span><br><span class="line">&#125;</span><br><span class="line">if (clazz == null) &#123;</span><br><span class="line">throw new ClassNotFoundException(className);</span><br><span class="line">&#125;</span><br><span class="line">return clazz;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Enumeration&lt;String&gt; entrys = dexFile.entries();</span><br><span class="line">Class&lt;?&gt; clazz = null;</span><br><span class="line">while (entrys.hasMoreElements()) &#123;</span><br><span class="line">String entry = entrys.nextElement();</span><br><span class="line">if (classes != null &amp;&amp; !classes.contains(entry)) &#123;</span><br><span class="line">continue;// skip, not need fix</span><br><span class="line">&#125;</span><br><span class="line">clazz = dexFile.loadClass(entry, patchClassLoader);</span><br><span class="line">if (clazz != null) &#123;</span><br><span class="line">// fixClass</span><br><span class="line">fixClass(clazz, classLoader);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">Log.e(TAG, &quot;pacth&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * fix class</span><br><span class="line"> * </span><br><span class="line"> * @param clazz</span><br><span class="line"> *            class</span><br><span class="line"> */</span><br><span class="line">private void fixClass(Class&lt;?&gt; clazz, ClassLoader classLoader) &#123;</span><br><span class="line">Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">// 方法注解，表明需要替换的方法</span><br><span class="line">MethodReplace methodReplace;</span><br><span class="line">String clz;</span><br><span class="line">String meth;</span><br><span class="line">for (Method method : methods) &#123;</span><br><span class="line">methodReplace = method.getAnnotation(MethodReplace.class);</span><br><span class="line">if (methodReplace == null)</span><br><span class="line">continue;</span><br><span class="line">// 从注解获取class和需要替换的方法名</span><br><span class="line">clz = methodReplace.clazz();</span><br><span class="line">meth = methodReplace.method();</span><br><span class="line">if (!isEmpty(clz) &amp;&amp; !isEmpty(meth)) &#123;</span><br><span class="line">replaceMethod(classLoader, clz, meth, method);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * replace method</span><br><span class="line"> * </span><br><span class="line"> * @param classLoader classloader</span><br><span class="line"> * @param clz class</span><br><span class="line"> * @param meth name of target method </span><br><span class="line"> * @param method source method</span><br><span class="line"> */</span><br><span class="line">private void replaceMethod(ClassLoader classLoader, String clz,</span><br><span class="line">String meth, Method method) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">String key = clz + &quot;@&quot; + classLoader.toString();</span><br><span class="line">Class&lt;?&gt; clazz = mFixedClass.get(key);</span><br><span class="line">if (clazz == null) &#123;// class not load</span><br><span class="line">Class&lt;?&gt; clzz = classLoader.loadClass(clz);</span><br><span class="line">// initialize target class</span><br><span class="line">clazz = AndFix.initTargetClass(clzz);</span><br><span class="line">&#125;</span><br><span class="line">if (clazz != null) &#123;// initialize class OK</span><br><span class="line">mFixedClass.put(key, clazz);</span><br><span class="line">Method src = clazz.getDeclaredMethod(meth,</span><br><span class="line">method.getParameterTypes());</span><br><span class="line">AndFix.addReplaceMethod(src, method);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">Log.e(TAG, &quot;replaceMethod&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void addReplaceMethod(Method src, Method dest) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">replaceMethod(src, dest);</span><br><span class="line">initFields(dest.getDeclaringClass());</span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line">Log.e(TAG, &quot;addReplaceMethod&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 最终调用native进行方法替换</span><br><span class="line">private static native void replaceMethod(Method dest, Method src);</span><br></pre></td></tr></table></figure></p><p>native进行方法替换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// andfix.cpp</span><br><span class="line">static void replaceMethod(JNIEnv* env, jclass clazz, jobject src,</span><br><span class="line">jobject dest) &#123;</span><br><span class="line">// 对不同的jvm实现进行判断区分</span><br><span class="line">if (isArt) &#123;</span><br><span class="line">art_replaceMethod(env, src, dest);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">dalvik_replaceMethod(env, src, dest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以查看art_method_replace.cpp中，是对不同版本的设备进行区分，ART可能会有不同版本的差异，需要单独处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">extern void __attribute__ ((visibility (&quot;hidden&quot;))) art_replaceMethod(</span><br><span class="line">JNIEnv* env, jobject src, jobject dest) &#123;</span><br><span class="line">    if (apilevel &gt; 23) &#123;</span><br><span class="line">        replace_7_0(env, src, dest);</span><br><span class="line">    &#125; else if (apilevel &gt; 22) &#123;</span><br><span class="line">replace_6_0(env, src, dest);</span><br><span class="line">&#125; else if (apilevel &gt; 21) &#123;</span><br><span class="line">replace_5_1(env, src, dest);</span><br><span class="line">&#125; else if (apilevel &gt; 19) &#123;</span><br><span class="line">replace_5_0(env, src, dest);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        replace_4_4(env, src, dest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以replace_7_0为例，对函数指针的替换，用新的method替换旧的method内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">void replace_7_0(JNIEnv* env, jobject src, jobject dest) &#123;</span><br><span class="line">art::mirror::ArtMethod* smeth =</span><br><span class="line">(art::mirror::ArtMethod*) env-&gt;FromReflectedMethod(src);</span><br><span class="line"></span><br><span class="line">art::mirror::ArtMethod* dmeth =</span><br><span class="line">(art::mirror::ArtMethod*) env-&gt;FromReflectedMethod(dest);</span><br><span class="line"></span><br><span class="line">//reinterpret_cast&lt;art::mirror::Class*&gt;(smeth-&gt;declaring_class_)-&gt;class_loader_ =</span><br><span class="line">//reinterpret_cast&lt;art::mirror::Class*&gt;(dmeth-&gt;declaring_class_)-&gt;class_loader_; //for plugin classloader</span><br><span class="line">reinterpret_cast&lt;art::mirror::Class*&gt;(dmeth-&gt;declaring_class_)-&gt;clinit_thread_id_ =</span><br><span class="line">reinterpret_cast&lt;art::mirror::Class*&gt;(smeth-&gt;declaring_class_)-&gt;clinit_thread_id_;</span><br><span class="line">reinterpret_cast&lt;art::mirror::Class*&gt;(dmeth-&gt;declaring_class_)-&gt;status_ =</span><br><span class="line">reinterpret_cast&lt;art::mirror::Class*&gt;(smeth-&gt;declaring_class_)-&gt;status_ -1;</span><br><span class="line">//for reflection invoke</span><br><span class="line">reinterpret_cast&lt;art::mirror::Class*&gt;(dmeth-&gt;declaring_class_)-&gt;super_class_ = 0;</span><br><span class="line"></span><br><span class="line">smeth-&gt;declaring_class_ = dmeth-&gt;declaring_class_;</span><br><span class="line">smeth-&gt;access_flags_ = dmeth-&gt;access_flags_  | 0x0001;</span><br><span class="line">smeth-&gt;dex_code_item_offset_ = dmeth-&gt;dex_code_item_offset_;</span><br><span class="line">smeth-&gt;dex_method_index_ = dmeth-&gt;dex_method_index_;</span><br><span class="line">smeth-&gt;method_index_ = dmeth-&gt;method_index_;</span><br><span class="line">smeth-&gt;hotness_count_ = dmeth-&gt;hotness_count_;</span><br><span class="line"></span><br><span class="line">smeth-&gt;ptr_sized_fields_.dex_cache_resolved_methods_ =</span><br><span class="line">dmeth-&gt;ptr_sized_fields_.dex_cache_resolved_methods_;</span><br><span class="line">smeth-&gt;ptr_sized_fields_.dex_cache_resolved_types_ =</span><br><span class="line">dmeth-&gt;ptr_sized_fields_.dex_cache_resolved_types_;</span><br><span class="line"></span><br><span class="line">smeth-&gt;ptr_sized_fields_.entry_point_from_jni_ =</span><br><span class="line">dmeth-&gt;ptr_sized_fields_.entry_point_from_jni_;</span><br><span class="line">smeth-&gt;ptr_sized_fields_.entry_point_from_quick_compiled_code_ =</span><br><span class="line">dmeth-&gt;ptr_sized_fields_.entry_point_from_quick_compiled_code_;</span><br><span class="line"></span><br><span class="line">LOGD(&quot;replace_7_0: %d , %d&quot;,</span><br><span class="line">smeth-&gt;ptr_sized_fields_.entry_point_from_quick_compiled_code_,</span><br><span class="line">dmeth-&gt;ptr_sized_fields_.entry_point_from_quick_compiled_code_);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、 <code>addPatch()</code>具体实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * add patch at runtime</span><br><span class="line"> *</span><br><span class="line"> * @param path .patch修复包的存放路径，patch path</span><br><span class="line"> * @throws IOException</span><br><span class="line"> */</span><br><span class="line">public void addPatch(String path) throws IOException &#123;</span><br><span class="line">    File src = new File(path);</span><br><span class="line">    File dest = new File(mPatchDir, src.getName());</span><br><span class="line">    if (!src.exists()) &#123;</span><br><span class="line">        throw new FileNotFoundException(path);</span><br><span class="line">    &#125;</span><br><span class="line">    if (dest.exists()) &#123;</span><br><span class="line">        Log.d(TAG, &quot;patch [&quot; + path + &quot;] has be loaded.&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 具体作用是将.patch文件copy到file文件目录下，删除patch文件后不影响修复效果</span><br><span class="line">    FileUtil.copyFile(src, dest);// copy to patch&apos;s directory</span><br><span class="line">    // 先进行.patch文件copy，热修复将一直使用的是file目录下的修复包</span><br><span class="line">    Patch patch = addPatch(dest);</span><br><span class="line">    if (patch != null) &#123;</span><br><span class="line">        loadPatch(patch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="四、归纳总结"><a href="#四、归纳总结" class="headerlink" title="四、归纳总结"></a>四、归纳总结</h4><blockquote><p>从阅读源码的过程中，可以发现AndFix的具有的一些特点，轻量，支持Android多版本，进行方法热修复，单纯的热修复功能，AndFix会将.patch做保存，会有一种一次修复持久有效的功效（即使删除下载之后的.patch文件）。相对缺少一些对于res布局文件修复的功能。<br>阅读的过程中，会有一些体会是，如果我去实现一个热修复框架应该考虑什么点，注意一些什么？去深入探索一下触手所不能及的地方，去看看，自己动手找找，可能会记忆更深刻。</p></blockquote><h4 id="参照"><a href="#参照" class="headerlink" title="参照"></a>参照</h4><ul><li><a href="https://juejin.im/entry/595f4a7d51882568b462fc4f" target="_blank" rel="noopener">热修复之 Method Hook 原理</a></li><li><a href="http://jackieming.com/blog/2017/04/02/Android%E7%83%AD%E8%A1%A5%E4%B8%81%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">Android热补丁笔记</a></li><li><a href="https://github.com/pqpo/MethodHook" target="_blank" rel="noopener">MethodHook</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/AndFix&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;AndFix&lt;/strong&gt;&lt;/a&gt; 是阿里系的一个轻量级热修复，热更新框架，只支持简单的method修改，没有res修复等臃肿功能。具体的实现是通过native进行原函数的指针替换，具有一次修复，持续有效的特性（当然是不清除app所有数据前提下）。&lt;code&gt;AndFix has a native method art_replaceMethod in ART or dalvik_replaceMethod in Dalvik.&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018_0401/principle.png&quot; alt=&quot;方法替换原理&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="三方框架" scheme="http://yoursite.com/categories/Android/%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="三方框架" scheme="http://yoursite.com/tags/%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>EventBus 源码赏析</title>
    <link href="http://yoursite.com/2018/03/29/EventBus-%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/"/>
    <id>http://yoursite.com/2018/03/29/EventBus-源码赏析/</id>
    <published>2018-03-29T14:04:31.000Z</published>
    <updated>2018-03-29T15:35:59.026Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-、简单概括"><a href="#一-、简单概括" class="headerlink" title="一 、简单概括"></a>一 、简单概括</h4><ul><li>EventBus是一个Android/Java平台基于订阅与发布的同通信框架，不支持跨进程。可以用于Activity/Fragment/Thread/Service之间通信解耦，也可以用于多线程通信。</li><li>EventBus相对于BroadcastReceiver、Handler、接口回调的有点在于简单，事件的订阅和发布解耦，但是存在的问题也很明显，会有大量的Event类来管理</li><li>Event bus for Android and Java that simplifies communication between Activities, Fragments, Threads, Services, etc. Less code, better quality.</li><li><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">GITHUB直连</a></li></ul><a id="more"></a> <h4 id="二、EventBus的基本使用"><a href="#二、EventBus的基本使用" class="headerlink" title="二、EventBus的基本使用"></a>二、EventBus的基本使用</h4><p><img src="https://raw.githubusercontent.com/guoxiaoxing/android-open-framework-analysis/master/art/eventbus/event_bus_structure.png" alt="整体思路"></p><ul><li>注册订阅者</li><li>发布、接收Event</li><li>取消注册订阅者</li></ul><h4 id="三、源码解析核心类"><a href="#三、源码解析核心类" class="headerlink" title="三、源码解析核心类"></a>三、源码解析核心类</h4><blockquote><p>分析如下几个类，基本可以理清EventBus的event register/post</p></blockquote><ul><li><code>EventBus.java</code> 对外使用的类和方法</li><li><code>Subscription.java</code> 其中关键的<code>final Object subscriber; // 订阅者final SubscriberMethod subscriberMethod; // 订阅者方法</code></li><li><code>SubscriberMethod.java</code> 其中关键的<code>final Method method; // 订阅者中的方法final ThreadMode threadMode; // 回调的线程模式final Class&lt;?&gt; eventType; // Event类型，订阅Map的Keyfinal int priority; // 优先级final boolean sticky; // 是否粘性</code></li></ul><h5 id="1-注册订阅者"><a href="#1-注册订阅者" class="headerlink" title="1. 注册订阅者"></a>1. 注册订阅者</h5><p><code>EventBus.getDefault().register(this)</code><br>getDefault() 为单例获取方法，也可以使用EventBusBuilder实现实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 订阅队列，**Map的Key为Event实例**，会将一组注册相同Event的归纳仅一个集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line"><span class="comment">// 后续准备取消的事件队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line"><span class="comment">// 粘性事件队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取订阅者的类名。</span></span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    <span class="comment">// 2. 查找当前订阅者的所有响应函数，即使用注解@Subscribe(threadMode = ThreadMode.MAIN)标记的方法，并将其得以封装在SubscriberMethod对象中</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. 循环每个事件响应函数</span></span><br><span class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如下是真正<code>subscribe()</code>的过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 事件类型（xxxEvent）</span></span><br><span class="line">      Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">      <span class="comment">// 1.将订阅者和订阅者的方法归纳到另一个对象中</span></span><br><span class="line">      Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</span><br><span class="line">      <span class="comment">// 2.拿到该事件类型的所有订阅信息。</span></span><br><span class="line">      CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">      <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果未有相同事件注册过，则创建一个此Event订阅列表</span></span><br><span class="line">          subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">          subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span> + eventType);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">      <span class="comment">// 3. 按照事件优先级将其插入订阅者列表中，其实就是插入顺序</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">              subscriptions.add(i, newSubscription);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 4. 得到当前订阅者订阅的所有事件队列，存放在typesBySubscriber中，用于后续取消事件订阅。</span></span><br><span class="line">      List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">      <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">          subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">      &#125;</span><br><span class="line">      subscribedEvents.add(eventType);</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 5. 是否是粘性事件，如果是粘性事件，则从stickyEvents队列中取出最后一个该类型的事件发送给订阅者。</span></span><br><span class="line">      <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">          <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">              <span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></span><br><span class="line">              <span class="comment">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></span><br><span class="line">              <span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></span><br><span class="line">              <span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></span><br><span class="line">              Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">              <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                  Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                  <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                      Object stickyEvent = entry.getValue();</span><br><span class="line">                      checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">              checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2-发布事件"><a href="#2-发布事件" class="headerlink" title="2. 发布事件"></a>2. 发布事件</h5><p><code>EventBus.getDefault().post(new Event(&quot;Event Message&quot;));</code><br>其具体的串联过程如下：<br><code>post()</code> -&gt; <code>postSingleEvent)()</code> -&gt; <code>postSingleEventForEventType()</code> -&gt; <code>postToSubscription()</code> -&gt; <code>invokeSubscriber()</code>  -&gt; <code>subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</code> -&gt; 最终通过反射调用订阅者的onEvent()，得以将消息传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取当前线程的PostingThreadState对象，该对象包含事件队列，保存在ThreadLocal中。ThreadLocal将需要被线程保护的对象放入其中，此对象将和线程绑定，意味着每个线程都有自己的事件队列</span></span><br><span class="line">    PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">    <span class="comment">// 2. 将当前事件加入到该线程的事件队列中。</span></span><br><span class="line">    eventQueue.add(event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 判断事件是否在分发中。如果没有则遍历事件队列进行实际分发。</span></span><br><span class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">        postingState.isMainThread = isMainThread();</span><br><span class="line">        postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 4. 事件分发并从队列中移除</span></span><br><span class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">            postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PostingThreadState用来描述发送事件的线程的相关状态信息，包含事件队列，是否是主线程、订阅者、事件Event等信息。</p></blockquote><ol><li>获取当前线程的PostingThreadState对象，该对象包含事件队列，保存在ThreadLocal中。</li><li>将当前事件加入到该线程的事件队列中。</li><li>判断事件是否在分发中。如果没有则遍历事件队列进行实际分发。</li><li>进行事件分发。</li></ol><p>然后调用postSingleEvent()进行事件分发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">    Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 1. 如果事件允许继承，则查找该事件类型的所有父类和接口，依次进行循环。</span></span><br><span class="line">    <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">            <span class="comment">// 2. 查找该事件的所有订阅者。</span></span><br><span class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!subscriptionFound) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">            logger.log(Level.FINE, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">            post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要做了以下事情：</p><ol><li>如果事件允许继承，则查找该事件类型的所有父类和接口，依次进行循环。</li><li>查找该事件的所有订阅者。</li></ol><p>然后调用postSingleEventForEventType()方法查询当前事件的所有订阅者，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 获取当前事件的所有订阅者。</span></span><br><span class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 2. 遍历所有订阅者。</span></span><br><span class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">            postingState.event = event;</span><br><span class="line">            postingState.subscription = subscription;</span><br><span class="line">            <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 根据订阅者所在线程，调用事件响应函数onEvent()。</span></span><br><span class="line">                postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                aborted = postingState.canceled;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postingState.event = <span class="keyword">null</span>;</span><br><span class="line">                postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">                postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要做了以下事情：</p><ol><li>获取当前事件的所有订阅者。</li><li>遍历所有订阅者。</li><li>根据订阅者所在线程，调用事件响应函数onEvent()。</li></ol><p>调用postToSubscription()方法根据订阅者所在线程，调用事件响应函数onEvent()，这便涉及到接收事件Event的处理了，我们接着来看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">           <span class="keyword">case</span> POSTING:</span><br><span class="line">               invokeSubscriber(subscription, event);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> MAIN:</span><br><span class="line">               <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                   invokeSubscriber(subscription, event);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">               <span class="keyword">if</span> (mainThreadPoster != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class="line">                   invokeSubscriber(subscription, event);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">               <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                   backgroundPoster.enqueue(subscription, event);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   invokeSubscriber(subscription, event);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> ASYNC:</span><br><span class="line">               asyncPoster.enqueue(subscription, event);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">    ·······</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，onEvent函数上是可以加Subscribe注解了，该注解标明了onEvent()函数在哪个线程执行。主要有以下几个线程：</p><ul><li>PostThread：默认的 ThreadMode，表示在执行 Post 操作的线程直接调用订阅者的事件响应方法，不论该线程是否为主线程（UI 线程）。当该线程为主线程<br>时，响应方法中不能有耗时操作，否则有卡主线程的风险。适用场景：对于是否在主线程执行无要求，但若 Post 线程为主线程，不能耗时的操作；</li><li>MainThread：在主线程中执行响应方法。如果发布线程就是主线程，则直接调用订阅者的事件响应方法，否则通过主线程的 Handler 发送消息在主线程中处理—<br>—调用订阅者的事件响应函数。显然，MainThread类的方法也不能有耗时操作，以避免卡主线程。适用场景：必须在主线程执行的操作；</li><li>BackgroundThread：在后台线程中执行响应方法。如果发布线程不是主线程，则直接调用订阅者的事件响应函数，否则启动唯一的后台线程去处理。由于后台线程<br>是唯一的，当事件超过一个的时候，它们会被放在队列中依次执行，因此该类响应方法虽然没有PostThread类和MainThread类方法对性能敏感，但最好不要有重度耗<br>时的操作或太频繁的轻度耗时操作，以造成其他操作等待。适用场景：操作轻微耗时且不会过于频繁，即一般的耗时操作都可以放在这里；</li><li>Async：不论发布线程是否为主线程，都使用一个空闲线程来处理。和BackgroundThread不同的是，Async类的所有线程是相互独立的，因此不会出现卡线程的问<br>题。适用场景：长耗时操作，例如网络访问。</li></ul><p>这里我线程执行和EventBus的成员变量对应，它们都实现了Runnable与Poster接口，Poster接口定义了事件排队功能，这些本质上都是个Runnable，放在线程池里执行，如下所示：</p><p><code>private final Poster mainThreadPoster;private final BackgroundPoster backgroundPoster;private final AsyncPoster asyncPoster;private final SubscriberMethodFinder subscriberMethodFinder;private final ExecutorService executorService;</code></p><h5 id="3-取消订阅"><a href="#3-取消订阅" class="headerlink" title="3. 取消订阅"></a>3. 取消订阅</h5><p>取消注册订阅者调用的是以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>具体如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 1. 获取当前订阅者订阅的所有事件类型。</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. 遍历事件队列，解除事件注册。</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">            unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 移除事件订阅者。</span></span><br><span class="line">        typesBySubscriber.remove(subscriber);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.log(Level.WARNING, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取消注册订阅者的流程也十分简单，如下所示：</p><ol><li>获取当前订阅者订阅的所有事件类型。</li><li>遍历事件队列，解除事件注册。</li><li>移除事件订阅者。</li></ol><p>当猴调用unsubscribeByEventType()移除订阅者，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 1. 获取所有订阅者信息。</span></span><br><span class="line">     List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">     <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>)</span><br><span class="line">         <span class="comment">// 2. 遍历订阅者</span></span><br><span class="line">         <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">             Subscription subscription = subscriptions.get(i);</span><br><span class="line">             <span class="comment">// 3. 移除该订阅对象。</span></span><br><span class="line">             <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">                 subscription.active = <span class="keyword">false</span>;</span><br><span class="line">                 subscriptions.remove(i);</span><br><span class="line">                 i--;</span><br><span class="line">                 size--;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><blockquote><p><code>EventBus</code>中使用到了现在一些比较主流的技术，注解、反射、ThreadLocal，组成了订阅发布的一组框架，从中能看到作者对Event的理解，以及在架构时对效率的考虑。从以eventClazz为Key，映射出所有订阅者的思想，和现实中以一对多的思想类似，代码的思想不是一点点得来的，停下笔思考一下，如何才会更好？</p><p> <strong>文中大多是从网上得来，只算自己的一种归纳整理吧。</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一-、简单概括&quot;&gt;&lt;a href=&quot;#一-、简单概括&quot; class=&quot;headerlink&quot; title=&quot;一 、简单概括&quot;&gt;&lt;/a&gt;一 、简单概括&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;EventBus是一个Android/Java平台基于订阅与发布的同通信框架，不支持跨进程。可以用于Activity/Fragment/Thread/Service之间通信解耦，也可以用于多线程通信。&lt;/li&gt;
&lt;li&gt;EventBus相对于BroadcastReceiver、Handler、接口回调的有点在于简单，事件的订阅和发布解耦，但是存在的问题也很明显，会有大量的Event类来管理&lt;/li&gt;
&lt;li&gt;Event bus for Android and Java that simplifies communication between Activities, Fragments, Threads, Services, etc. Less code, better quality.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/greenrobot/EventBus&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GITHUB直连&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="三方框架" scheme="http://yoursite.com/categories/Android/%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="三方框架" scheme="http://yoursite.com/tags/%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android LocalBroadcastManager的使用及源码解析</title>
    <link href="http://yoursite.com/2018/01/08/Android-LocalBroadcastManager%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/01/08/Android-LocalBroadcastManager的使用及源码解析/</id>
    <published>2018-01-08T15:25:34.000Z</published>
    <updated>2018-03-29T15:18:17.638Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt; 
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android AIDL Binder框架分析</title>
    <link href="http://yoursite.com/2018/01/07/Android-AIDL-Binder%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/01/07/Android-AIDL-Binder框架分析/</id>
    <published>2018-01-07T15:29:25.000Z</published>
    <updated>2018-03-29T15:18:11.822Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt; 
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Messenger跨进程通信</title>
    <link href="http://yoursite.com/2018/01/03/Android-Messenger%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2018/01/03/Android-Messenger跨进程通信/</id>
    <published>2018-01-02T16:41:33.000Z</published>
    <updated>2018-01-04T15:57:36.598Z</updated>
    
    <content type="html"><![CDATA[<!-- http://blog.csdn.net/lmj623565791/article/details/47017485 --><ul><li><a href="https://developer.android.com/reference/android/os/Messenger.html" target="_blank" rel="noopener">Google API</a> Reference to a Handler, which others can use to send messages to it. This allows for the implementation of message-based communication across processes, by creating a Messenger pointing to a Handler in one process, and handing that Messenger to another process.<br><em>Messenger允许跨进程基于消息的通信，通过在一个进程创建指向Handler的Messenger，然后在另外一个进程处理。</em><br>Note: the implementation underneath is just a simple wrapper around a <a href="https://developer.android.com/reference/android/os/Binder.html" target="_blank" rel="noopener">Binder</a> that is used to perform the communication.<br><em>Messenger是Binder的简单包装。</em></li><li>参见 <a href="https://developer.android.com/reference/android/app/Service.html#RemoteMessengerServiceSample" target="_blank" rel="noopener">Google Remote Messenger Sample</a></li></ul><a id="more"></a><blockquote><p>跨进程简单理解模型：<br><img src="/images/2018_0103/client_server.png" alt=""></p></blockquote><h2 id="一、-Demo演示"><a href="#一、-Demo演示" class="headerlink" title="一、 Demo演示"></a>一、 Demo演示</h2><p>同一个App中，将Service设置为remote，实现一个App多个进程。</p><h3 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h3><h4 id="Service代码"><a href="#Service代码" class="headerlink" title="Service代码"></a>Service代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.Service;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.os.Messenger;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Mia.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_DIFF = <span class="number">0x110</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Messenger messenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> Handler() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msgFromClient)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Message.obtain(Message),通过已有Message对象创建同样属性的Message对象</span></span><br><span class="line">            <span class="comment">// copies the values of an existing message (including its target) into the new one.</span></span><br><span class="line">            Message msgToClient = Message.obtain(msgFromClient);</span><br><span class="line">            <span class="keyword">switch</span> (msgFromClient.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MSG_DIFF:</span><br><span class="line">                    msgToClient.what = MSG_DIFF;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                        msgToClient.arg2 = msgFromClient.arg1 - msgFromClient.arg2;</span><br><span class="line">                        msgFromClient.replyTo.send(msgToClient);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException | RemoteException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msgFromClient);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置在AndroidManifest-xml"><a href="#配置在AndroidManifest-xml" class="headerlink" title="配置在AndroidManifest.xml"></a>配置在AndroidManifest.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置remote之后，不仅仅是进程id不同了，就连应用程序包名也不一样了，包名后面还跟上了:remote标识。 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"*.ServerService"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">":remote"</span> &gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h3><h4 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.ComponentName;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.ServiceConnection;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.os.Messenger;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.LinearLayout;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button mBtnAdd;</span><br><span class="line">    <span class="keyword">private</span> LinearLayout mLyContainer;</span><br><span class="line">    <span class="comment">//显示连接状态</span></span><br><span class="line">    <span class="keyword">private</span> TextView mTvState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Messenger mService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isConn;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Messenger mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> Handler()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msgFromServer)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msgFromServer.what)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> ServerService.MSG_DIFF:</span><br><span class="line">                    TextView tv = (TextView) mLyContainer.findViewById(msgFromServer.arg1);</span><br><span class="line">                    tv.setText(tv.getText() + <span class="string">"=&gt;"</span> + msgFromServer.arg2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msgFromServer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConn = <span class="keyword">new</span> ServiceConnection()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            mService = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">            isConn = <span class="keyword">true</span>;</span><br><span class="line">            mTvState.setText(<span class="string">"connected!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            mService = <span class="keyword">null</span>;</span><br><span class="line">            isConn = <span class="keyword">false</span>;</span><br><span class="line">            mTvState.setText(<span class="string">"disconnected!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mA;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始绑定服务</span></span><br><span class="line">        bindServiceInvoked();</span><br><span class="line"></span><br><span class="line">        mTvState = (TextView) findViewById(R.id.id_tv_callback);</span><br><span class="line">        mBtnAdd = (Button) findViewById(R.id.id_btn_add);</span><br><span class="line">        mLyContainer = (LinearLayout) findViewById(R.id.id_ll_container);</span><br><span class="line"></span><br><span class="line">        mBtnAdd.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> a = mA++;</span><br><span class="line">                    <span class="keyword">int</span> b = (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//创建一个tv,添加到LinearLayout中</span></span><br><span class="line">                    TextView tv = <span class="keyword">new</span> TextView(MainActivity.<span class="keyword">this</span>);</span><br><span class="line">                    tv.setText(a + <span class="string">" + "</span> + b + <span class="string">" = caculating ..."</span>);</span><br><span class="line">                    tv.setId(a);</span><br><span class="line">                    mLyContainer.addView(tv);</span><br><span class="line"></span><br><span class="line">                    Message msgFromClient = Message.obtain(<span class="keyword">null</span>, ServerService.MSG_DIFF, a, b);</span><br><span class="line">                    msgFromClient.replyTo = mMessenger;</span><br><span class="line">                    <span class="keyword">if</span> (isConn)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//往服务端发送消息</span></span><br><span class="line">                        mService.send(msgFromClient);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindServiceInvoked</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setAction(<span class="string">"com.zhy.aidl.calc"</span>);</span><br><span class="line">        bindService(intent, mConn, Context.BIND_AUTO_CREATE);</span><br><span class="line">        Log.e(TAG, <span class="string">"bindService invoked !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        unbindService(mConn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Layout-xml"><a href="#Layout-xml" class="headerlink" title="Layout.xml"></a>Layout.xml</h4><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><h2 id="二、-源码分析"><a href="#二、-源码分析" class="headerlink" title="二、 源码分析"></a>二、 源码分析</h2><p><strong>一句话总结：</strong>Messenger的内部实现的，实际上也是依赖于aidl文件实现的。</p><h3 id="客户端向服务端通信"><a href="#客户端向服务端通信" class="headerlink" title="客户端向服务端通信"></a>客户端向服务端通信</h3><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>1.服务端中的Service#onBind():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMessenger.getBinder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.其mMessenger.getBinder()具体实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IBinder <span class="title">getBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mTarget.asBinder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.其mTarget对象即是new Messenger(Handler)的Handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(Handler target)</span> </span>&#123;</span><br><span class="line">    mTarget = target.getIMessenger();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.进入target.getIMessenger(),观察其实现细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> IMessenger <span class="title">getIMessenger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mQueue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mMessenger != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mMessenger;</span><br><span class="line">        &#125;</span><br><span class="line">        mMessenger = <span class="keyword">new</span> MessengerImpl();</span><br><span class="line">        <span class="keyword">return</span> mMessenger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerImpl</span> <span class="keyword">extends</span> <span class="title">IMessenger</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        msg.sendingUid = Binder.getCallingUid();</span><br><span class="line">        Handler.<span class="keyword">this</span>.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mTarget实质上是一个MessengerImpl对象，那么asBinder实际上是返回this，也就是MessengerImpl对象；<br>这是个内部类，可以看到继承自IMessenger.Stub，然后实现了一个send方法，该方法就是将接收到的消息通过 Handler.this.sendMessage(msg);<br>发送到handleMessage方法。<br>传统写aidl文件，aapt给我们生成什么，生成IXXX.Stub类，然后我们服务端继承IXXX.Stub实现接口中的方法。<br>没错，其实这里内部其实也是依赖一个aidl生成的类，这个aidl位于：frameworks/base/core/java/android/os/IMessenger.aidl.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> android.os;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Message;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span>  </span><br><span class="line">oneway <span class="class"><span class="keyword">interface</span> <span class="title">IMessenger</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(in Message msg)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Messenger并没有什么神奇之处，实际上，就是依赖该aidl文件生成的类，继承了IMessenger.Stub类，<br>实现了send方法，send方法中参数会通过客户端传递过来，最终发送给handler进行处理。</p><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><p>客户端首先通过onServiceConnected拿到sevice（Ibinder）对象IMessenger.Stub.asInterface(service)拿到接口对象进行调用；<br>而，我们的代码中是mService = new Messenger(service);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(IBinder target)</span> </span>&#123;</span><br><span class="line">    mTarget = IMessenger.Stub.asInterface(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实质与平常写法一致！<br>客户端与服务端通信，实际上和我们平时的写法没有任何区别，通过编写aidl文件，服务端onBind利用Stub编写接口实现返回；客户端利用回调得到的IBinder对象，使用IMessenger.Stub.asInterface(target)拿到接口实例进行调用（内部实现）。</p><h3 id="服务端向客户端通信"><a href="#服务端向客户端通信" class="headerlink" title="服务端向客户端通信"></a>服务端向客户端通信</h3><p>客户端send方法发送的是一个Message，这个Message.replyTo指向的是一个mMessenger，是我们自己初始化的，用于服务端向客户端通信。<br>那么将消息发送到服务端，肯定是通过序列化与反序列化拿到Message对象，我们看下Message的反序列化的代码：</p><h4 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">    what = source.readInt();</span><br><span class="line">    arg1 = source.readInt();</span><br><span class="line">    arg2 = source.readInt();</span><br><span class="line">    <span class="keyword">if</span> (source.readInt() != <span class="number">0</span>) &#123;</span><br><span class="line">        obj = source.readParcelable(getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    when = source.readLong();</span><br><span class="line">    data = source.readBundle();</span><br><span class="line">    replyTo = Messenger.readMessengerOrNullFromParcel(source);</span><br><span class="line">    sendingUid = source.readInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要看replyTo，调用的是Messenger.readMessengerOrNullFromParcel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Messenger <span class="title">readMessengerOrNullFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">    IBinder b = in.readStrongBinder();</span><br><span class="line">    <span class="keyword">return</span> b != <span class="keyword">null</span> ? <span class="keyword">new</span> Messenger(b) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeMessengerOrNullToParcel</span><span class="params">(Messenger messenger,</span></span></span><br><span class="line"><span class="function"><span class="params">        Parcel out)</span> </span>&#123;</span><br><span class="line">    out.writeStrongBinder(messenger != <span class="keyword">null</span> ? messenger.mTarget.asBinder()</span><br><span class="line">            : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的writeMessengerOrNullToParcel可以看到，它将客户端的messenger.mTarget.asBinder()对象进行了恢复，客户端的message.mTarget.asBinder()是什么？<br>客户端也是通过Handler创建的Messenger，于是asBinder返回的是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(Handler target)</span> </span>&#123;</span><br><span class="line">    mTarget = target.getIMessenger();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> IMessenger <span class="title">getIMessenger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mQueue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mMessenger != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mMessenger;</span><br><span class="line">        &#125;</span><br><span class="line">        mMessenger = <span class="keyword">new</span> MessengerImpl();</span><br><span class="line">        <span class="keyword">return</span> mMessenger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerImpl</span> <span class="keyword">extends</span> <span class="title">IMessenger</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">         msg.sendingUid = Binder.getCallingUid();</span><br><span class="line">         Handler.<span class="keyword">this</span>.sendMessage(msg);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IBinder <span class="title">getBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> mTarget.asBinder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么asBinder，实际上就是MessengerImpl extends IMessenger.Stub中的asBinder了。</p><h4 id="IMessenger-Stub"><a href="#IMessenger-Stub" class="headerlink" title="IMessenger.Stub"></a>IMessenger.Stub</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么其实返回的就是MessengerImpl对象自己。到这里可以看到message.mTarget.asBinder()其实返回的是客户端的MessengerImpl对象。</p><p>最终，发送给客户端的代码是这么写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msgfromClient.replyTo.send(msgToClient);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    mTarget.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个mTarget实际上就是对客户端的MessengerImpl对象的封装，那么send(message)（屏蔽了transact/onTransact的细节），这个message最终肯定传到客户端的handler的handleMessage方法中。</p><blockquote><p><strong>一句话总结：</strong></p><ul><li>客户端通过bindService拿到服务端的Messenger对象；</li><li>客户端给服务端发送消息的时候，使用Messager.replyTo携带客户端的Messenger对象到服务端；</li><li>这样，客户端/服务端互相持有对方Binder对象（MessengerImpl）；</li><li>实质还是利用了AIDL的方式。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- http://blog.csdn.net/lmj623565791/article/details/47017485 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.android.com/reference/android/os/Messenger.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google API&lt;/a&gt; Reference to a Handler, which others can use to send messages to it. This allows for the implementation of message-based communication across processes, by creating a Messenger pointing to a Handler in one process, and handing that Messenger to another process.&lt;br&gt;&lt;em&gt;Messenger允许跨进程基于消息的通信，通过在一个进程创建指向Handler的Messenger，然后在另外一个进程处理。&lt;/em&gt;&lt;br&gt;Note: the implementation underneath is just a simple wrapper around a &lt;a href=&quot;https://developer.android.com/reference/android/os/Binder.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Binder&lt;/a&gt; that is used to perform the communication.&lt;br&gt;&lt;em&gt;Messenger是Binder的简单包装。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;参见 &lt;a href=&quot;https://developer.android.com/reference/android/app/Service.html#RemoteMessengerServiceSample&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google Remote Messenger Sample&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java Json转Map/List</title>
    <link href="http://yoursite.com/2017/12/28/Java-Json%E8%BD%ACMap-List/"/>
    <id>http://yoursite.com/2017/12/28/Java-Json转Map-List/</id>
    <published>2017-12-28T15:08:41.000Z</published>
    <updated>2017-12-28T15:29:42.671Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java-Json转Map-List"><a href="#Java-Json转Map-List" class="headerlink" title="Java Json转Map/List"></a>Java Json转Map/List</h3><hr><h4 id="Json格式"><a href="#Json格式" class="headerlink" title="Json格式"></a>Json格式</h4><blockquote><p>将格式如下的Json，转化成Map<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">“key1<span class="string">":"</span>value1<span class="string">",</span></span><br><span class="line"><span class="string">“key2"</span>:<span class="string">"value2"</span>,</span><br><span class="line">“key3<span class="string">":"</span>value3<span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p>将格式如下的Json，转化成List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"key"</span>:&#123;<span class="string">"key01"</span>:<span class="string">"value01"</span>,<span class="string">"key02"</span>:<span class="string">"value02"</span>,<span class="string">"key03"</span>:<span class="string">"value03"</span>&#125;,</span><br><span class="line"><span class="string">"key1"</span>:&#123;<span class="string">"key01"</span>:<span class="string">"value01"</span>,<span class="string">"key02"</span>:<span class="string">"value02"</span>,<span class="string">"key03"</span>:<span class="string">"value03"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><a id="more"></a> <hr><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><blockquote><p>直接撸代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Json转Map</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jsonStr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">getMapFromJSON</span><span class="params">(String jsonStr)</span> </span>&#123;</span><br><span class="line">    JSONObject jo;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        jo = <span class="keyword">new</span> JSONObject(jsonStr);</span><br><span class="line">        Iterator&lt;String&gt; iterator = jo.keys();</span><br><span class="line">        String key;</span><br><span class="line">        Object value;</span><br><span class="line">        HashMap&lt;String, Object&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            key = iterator.next();</span><br><span class="line">            value = jo.get(key);</span><br><span class="line">            hashMap.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hashMap;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Json转换成List&lt;Map&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jsonStr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Map&lt;String, Object&gt;&gt; getListFromJSON(String jsonStr) &#123;</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        JSONArray jsonArray = <span class="keyword">new</span> JSONArray(jsonStr);</span><br><span class="line">        JSONObject jsonObject;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = jsonArray.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            jsonObject = (JSONObject) jsonArray.get(i);</span><br><span class="line">            list.add(getMapFromJSON(jsonObject.toString()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java-Json转Map-List&quot;&gt;&lt;a href=&quot;#Java-Json转Map-List&quot; class=&quot;headerlink&quot; title=&quot;Java Json转Map/List&quot;&gt;&lt;/a&gt;Java Json转Map/List&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;Json格式&quot;&gt;&lt;a href=&quot;#Json格式&quot; class=&quot;headerlink&quot; title=&quot;Json格式&quot;&gt;&lt;/a&gt;Json格式&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;将格式如下的Json，转化成Map&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;“key1&lt;span class=&quot;string&quot;&gt;&quot;:&quot;&lt;/span&gt;value1&lt;span class=&quot;string&quot;&gt;&quot;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;“key2&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;value2&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;“key3&lt;span class=&quot;string&quot;&gt;&quot;:&quot;&lt;/span&gt;value3&lt;span class=&quot;string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将格式如下的Json，转化成List&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;key&quot;&lt;/span&gt;:&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;key01&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;value01&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;key02&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;value02&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;key03&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;value03&quot;&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;key1&quot;&lt;/span&gt;:&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;key01&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;value01&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;key02&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;value02&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;key03&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;value03&quot;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android反编译APK</title>
    <link href="http://yoursite.com/2017/12/25/Android%E5%8F%8D%E7%BC%96%E8%AF%91APK%E5%8F%8AADB%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2017/12/25/Android反编译APK及ADB命令/</id>
    <published>2017-12-25T14:23:59.000Z</published>
    <updated>2017-12-28T15:04:25.567Z</updated>
    
    <content type="html"><![CDATA[<p><strong>反编译可以理解为逆向工程（Reverse Engineering）</strong><br>通过反编译APK，可以更好的理解APK打包过程，可以验证特性和动态替换资源。使用工具<a href="https://github.com/google/android-classyshark" target="_blank" rel="noopener">ClassyShark</a></p><h2 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h2><h3 id="APK-Application-Package"><a href="#APK-Application-Package" class="headerlink" title="APK(Application Package)"></a>APK(Application Package)</h3><p><strong>APK实质上为压缩包，可以直接解压，解压后可以获得的信息</strong></p><blockquote><ul><li>AndroidManifest.xml：清单文件</li><li>classes.dex：Dex格式编译文件，classes压缩包</li><li>res：不需要编译的文件，一般都是系统资源文件</li><li>assets：AssetManager</li><li>META-INF：Jar包元数据，也包含应用签名</li></ul></blockquote><a id="more"></a> <p><strong>安装应用</strong></p><blockquote><p>adb install -r *.apk<br>-r 表示强制安装，覆盖当前版本</p></blockquote><p><strong>查看手机中的所有应用信息</strong></p><blockquote><p>adb shell pm list packages -f</p></blockquote><p><strong>导出手机中的apk(root 手机)</strong></p><blockquote><p>adb pull -p /data/app/me.chunyu.Pedometer-1/base.apk base.apk</p></blockquote><h3 id="AAPT-Android-Assets-Packaging-Tool"><a href="#AAPT-Android-Assets-Packaging-Tool" class="headerlink" title="AAPT(Android Assets Packaging Tool)"></a>AAPT(Android Assets Packaging Tool)</h3><p><strong>Android 打包工具</strong></p><blockquote><p>在Android sdk的build-tools文件夹中</p></blockquote><p><strong>获取apk信息</strong></p><blockquote><ul><li>aapt list base.apk // 内容</li><li>aapt dump badging base.apk // 属性</li><li>aapt dump permissions base.apk // 权限</li><li>aapt dump resources base.apk // 资源</li></ul></blockquote><p><strong>获取二进制xml信息</strong></p><blockquote><p>aapt dump xmltree base.apk AndroidManifest.xml</p></blockquote><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><h3 id="dex2jar"><a href="#dex2jar" class="headerlink" title="dex2jar"></a>dex2jar</h3><p><strong><a href="https://github.com/pxb1988/dex2jar" target="_blank" rel="noopener">dex2jar</a>是dex转换jar的工具，还需要使用Java包解析工具<a href="http://jd.benow.ca/" target="_blank" rel="noopener">JD-GUI</a></strong></p><blockquote><p>使用步骤：</p><ol><li>apk解压后，可以获得classes.dex(有可能不止一个)</li><li>使用命令<strong>d2j-dex2jar classes.dex</strong>进行格式转换，得到<strong>classes-dex2jar.jar</strong></li><li>得到的jar可以使用<strong>JD-GUI</strong>查看</li></ol></blockquote><h3 id="apktool"><a href="#apktool" class="headerlink" title="apktool"></a>apktool</h3><p><strong>进行资源的反编译，<a href="https://ibotpeaches.github.io/Apktool/install/" target="_blank" rel="noopener">ApkTool Download Page</a></strong></p><blockquote><p>使用步骤：</p><ol><li>apktool d base.apk</li><li>执行完成后，就会生成包含资源文件的test文件夹：<br>|.<br>| original<br>| res<br>| smali<br>| AndroidManifest.xml<br>| apktool.yml</li></ol></blockquote><h2 id="重打包"><a href="#重打包" class="headerlink" title="重打包"></a>重打包</h2><p><strong>1. 既然已经顺利进行了反编译，修改之后，可以使用命令进行重新打包</strong></p><blockquote><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apktool b test -o new_test.apk</span><br><span class="line">// 执行完成之后，会生成一个new_test.apk</span><br></pre></td></tr></table></figure></blockquote><p><strong>2. 重新打包之后的apk需要重新签名</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore 签名文件名 -storepass 签名密码 待签名的APK文件名 签名的别名</span><br><span class="line">// 其中jarsigner命令文件是存放在jdk的bin目录下的，需要将bin目录配置在系统的环境变量中才可以在任何位置执行此命令</span><br></pre></td></tr></table></figure></blockquote><p><strong>3. 签名完成之后，需要对APK进行一次对齐操作</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zipalign 4 new_test.apk new_test_aligned.apk</span><br><span class="line">// 对齐操作使用的是zipalign工具，该工具在&lt;Android SDK&gt;/build-tools/&lt;version&gt;目录下</span><br></pre></td></tr></table></figure></blockquote><p><strong>4. 验证apk签名是否成功</strong></p><blockquote><p><code>jarsigner -verify -verbose -certs new_test_aligned.apk</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;反编译可以理解为逆向工程（Reverse Engineering）&lt;/strong&gt;&lt;br&gt;通过反编译APK，可以更好的理解APK打包过程，可以验证特性和动态替换资源。使用工具&lt;a href=&quot;https://github.com/google/android-classyshark&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ClassyShark&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Base&quot;&gt;&lt;a href=&quot;#Base&quot; class=&quot;headerlink&quot; title=&quot;Base&quot;&gt;&lt;/a&gt;Base&lt;/h2&gt;&lt;h3 id=&quot;APK-Application-Package&quot;&gt;&lt;a href=&quot;#APK-Application-Package&quot; class=&quot;headerlink&quot; title=&quot;APK(Application Package)&quot;&gt;&lt;/a&gt;APK(Application Package)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;APK实质上为压缩包，可以直接解压，解压后可以获得的信息&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;AndroidManifest.xml：清单文件&lt;/li&gt;
&lt;li&gt;classes.dex：Dex格式编译文件，classes压缩包&lt;/li&gt;
&lt;li&gt;res：不需要编译的文件，一般都是系统资源文件&lt;/li&gt;
&lt;li&gt;assets：AssetManager&lt;/li&gt;
&lt;li&gt;META-INF：Jar包元数据，也包含应用签名&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>HEXO切换电脑重新部署</title>
    <link href="http://yoursite.com/2017/12/19/HEXO%E5%88%87%E6%8D%A2%E7%94%B5%E8%84%91%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2017/12/19/HEXO切换电脑重新部署/</id>
    <published>2017-12-19T15:33:26.000Z</published>
    <updated>2017-12-19T16:02:52.780Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件夹拷贝"><a href="#文件夹拷贝" class="headerlink" title="文件夹拷贝"></a>文件夹拷贝</h3><blockquote><p>将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。</p><ol><li>讨论下哪些文件是必须拷贝的：首先是之前自己修改的文件，像站点配置<strong>_config.yml</strong>，<strong>theme</strong>文件夹里面的主题，以及<strong>source</strong>里面自己写的博客文件，这些肯定要拷贝的。除此之外，还有三个文件需要有，就是<strong>scaffolds</strong>文件夹（文章的模板）、<strong>package.json</strong>（说明使用哪些包）和<strong>.gitignore</strong>（限定在提交的时候哪些文件可以忽略）。其实，这三个文件不是我们修改的，所以即使丢失了，也没有关系，我们可以建立一个新的文件夹，然后在里面执行hexo init，就会生成这三个文件，我们只需要将它们拷贝过来使用即可。<br><strong>总结</strong>:<strong>_config.yml</strong>，<strong>theme/</strong>，<strong>source/</strong>，<strong>scaffolds/</strong>，<strong>package.json</strong>，<strong>.gitignore</strong>，是需要拷贝的。</li><li>再讨论下哪些文件是不必拷贝的，或者说可以删除的：首先是<strong>.git</strong>文件，无论是在站点根目录下，还是主题目录下的<strong>.git</strong>文件，都可以删掉。然后是文件夹<strong>node_modules</strong>（在用<strong>npm install</strong>会重新生成），<strong>public</strong>（这个在用<strong>hexo g</strong>时会重新生成），<strong>.deploy_git</strong>文件夹（在使用hexo d时也会重新生成），<strong>db.json</strong>文件。其实上面这些文件也就是是<strong>.gitignore</strong>文件里面记载的可以忽略的内容。<br><strong>总结</strong>：<strong>.git/</strong>，<strong>node_modules/</strong>，<strong>public/</strong>，<strong>.deploy_git/</strong>，<strong>db.json</strong>文件需要删除。</li></ol></blockquote><a id="more"></a> <h3 id="模块安装"><a href="#模块安装" class="headerlink" title="模块安装"></a>模块安装</h3><blockquote><p>在新拷贝的文件夹里，右键选择<strong>git bash</strong>，使用<strong>npm install</strong>命令，进行模块安装。<br><em>这里不要使用<strong>hexo init</strong>初始化</em>，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。</p></blockquote><h3 id="安装一些必要组件"><a href="#安装一些必要组件" class="headerlink" title="安装一些必要组件"></a>安装一些必要组件</h3><blockquote><ol><li>为了使用hexo d来部署到git上，需要安装:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ol><li>为了建立RSS订阅，需要安装:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><ol><li>为了建立站点地图，需要安装:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><ul><li>至此环境在环境已经具备的情况下，使用指令部署到Github:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;文件夹拷贝&quot;&gt;&lt;a href=&quot;#文件夹拷贝&quot; class=&quot;headerlink&quot; title=&quot;文件夹拷贝&quot;&gt;&lt;/a&gt;文件夹拷贝&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;讨论下哪些文件是必须拷贝的：首先是之前自己修改的文件，像站点配置&lt;strong&gt;_config.yml&lt;/strong&gt;，&lt;strong&gt;theme&lt;/strong&gt;文件夹里面的主题，以及&lt;strong&gt;source&lt;/strong&gt;里面自己写的博客文件，这些肯定要拷贝的。除此之外，还有三个文件需要有，就是&lt;strong&gt;scaffolds&lt;/strong&gt;文件夹（文章的模板）、&lt;strong&gt;package.json&lt;/strong&gt;（说明使用哪些包）和&lt;strong&gt;.gitignore&lt;/strong&gt;（限定在提交的时候哪些文件可以忽略）。其实，这三个文件不是我们修改的，所以即使丢失了，也没有关系，我们可以建立一个新的文件夹，然后在里面执行hexo init，就会生成这三个文件，我们只需要将它们拷贝过来使用即可。&lt;br&gt;&lt;strong&gt;总结&lt;/strong&gt;:&lt;strong&gt;_config.yml&lt;/strong&gt;，&lt;strong&gt;theme/&lt;/strong&gt;，&lt;strong&gt;source/&lt;/strong&gt;，&lt;strong&gt;scaffolds/&lt;/strong&gt;，&lt;strong&gt;package.json&lt;/strong&gt;，&lt;strong&gt;.gitignore&lt;/strong&gt;，是需要拷贝的。&lt;/li&gt;
&lt;li&gt;再讨论下哪些文件是不必拷贝的，或者说可以删除的：首先是&lt;strong&gt;.git&lt;/strong&gt;文件，无论是在站点根目录下，还是主题目录下的&lt;strong&gt;.git&lt;/strong&gt;文件，都可以删掉。然后是文件夹&lt;strong&gt;node_modules&lt;/strong&gt;（在用&lt;strong&gt;npm install&lt;/strong&gt;会重新生成），&lt;strong&gt;public&lt;/strong&gt;（这个在用&lt;strong&gt;hexo g&lt;/strong&gt;时会重新生成），&lt;strong&gt;.deploy_git&lt;/strong&gt;文件夹（在使用hexo d时也会重新生成），&lt;strong&gt;db.json&lt;/strong&gt;文件。其实上面这些文件也就是是&lt;strong&gt;.gitignore&lt;/strong&gt;文件里面记载的可以忽略的内容。&lt;br&gt;&lt;strong&gt;总结&lt;/strong&gt;：&lt;strong&gt;.git/&lt;/strong&gt;，&lt;strong&gt;node_modules/&lt;/strong&gt;，&lt;strong&gt;public/&lt;/strong&gt;，&lt;strong&gt;.deploy_git/&lt;/strong&gt;，&lt;strong&gt;db.json&lt;/strong&gt;文件需要删除。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Setup" scheme="http://yoursite.com/categories/Setup/"/>
    
    
      <category term="Setup" scheme="http://yoursite.com/tags/Setup/"/>
    
  </entry>
  
  <entry>
    <title>Android 截屏方式总结</title>
    <link href="http://yoursite.com/2017/12/18/Android-%E6%88%AA%E5%B1%8F%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/12/18/Android-截屏方式总结/</id>
    <published>2017-12-18T12:18:19.000Z</published>
    <updated>2017-12-18T12:22:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-Android如何禁止Application截屏？"><a href="#一-Android如何禁止Application截屏？" class="headerlink" title="一. Android如何禁止Application截屏？"></a>一. Android如何禁止Application截屏？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);</span><br></pre></td></tr></table></figure><blockquote><p>如果一遍不行，那就来两遍。<a href="https://stackoverflow.com/questions/28606689/how-to-prevent-screen-capture-in-android" target="_blank" rel="noopener">FLAG_SECURE.StackOverflow</a></p></blockquote><a id="more"></a> <h2 id="二-如何监听截屏"><a href="#二-如何监听截屏" class="headerlink" title="二. 如何监听截屏"></a>二. 如何监听截屏</h2><blockquote><p>使用ContentObserver进行相册的监听,<a href="https://stackoverflow.com/questions/31360296/listen-for-screenshot-action-in-android" target="_blank" rel="noopener">原链</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 定义 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ScreenShotContentObserver</span> <span class="keyword">extends</span> <span class="title">ContentObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isFromEdit = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> String previousPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScreenShotContentObserver</span><span class="params">(Handler handler, Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler);</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deliverSelfNotifications</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.deliverSelfNotifications();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onChange(selfChange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange, Uri uri)</span> </span>&#123;</span><br><span class="line">        Cursor cursor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cursor = context.getContentResolver().query(uri, <span class="keyword">new</span> String[]&#123;</span><br><span class="line">                    MediaStore.Images.Media.DISPLAY_NAME,</span><br><span class="line">                    MediaStore.Images.Media.DATA</span><br><span class="line">            &#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (cursor != <span class="keyword">null</span> &amp;&amp; cursor.moveToLast()) &#123;</span><br><span class="line">                <span class="keyword">int</span> displayNameColumnIndex = cursor.getColumnIndex(MediaStore.Images.Media.DISPLAY_NAME);</span><br><span class="line">                <span class="keyword">int</span> dataColumnIndex = cursor.getColumnIndex(MediaStore.Images.Media.DATA);</span><br><span class="line">                String fileName = cursor.getString(displayNameColumnIndex);</span><br><span class="line">                String path = cursor.getString(dataColumnIndex);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> File(path).lastModified() &gt;= System.currentTimeMillis() - <span class="number">10000</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isScreenshot(path) &amp;&amp; !isFromEdit &amp;&amp; !(previousPath != <span class="keyword">null</span> &amp;&amp; previousPath.equals(path))) &#123;</span><br><span class="line">                        onScreenShot(path, fileName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    previousPath = path;</span><br><span class="line">                    isFromEdit = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cursor.close();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            isFromEdit = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cursor.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onChange(selfChange, uri);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isScreenshot</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> path != <span class="keyword">null</span> &amp;&amp; path.toLowerCase().contains(<span class="string">"screenshot"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onScreenShot</span><span class="params">(String path, String fileName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 使用 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ScreenShotContentObserver screenShotContentObserver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        screenShotContentObserver = <span class="keyword">new</span> ScreenShotContentObserver(handler, <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onScreenShot</span><span class="params">(String path, String fileName)</span> </span>&#123;</span><br><span class="line">                File file = <span class="keyword">new</span> File(path); <span class="comment">//this is the file of screenshot image</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        getContentResolver().registerContentObserver(</span><br><span class="line">            MediaStore.Images.Media.EXTERNAL_CONTENT_URI,</span><br><span class="line">                <span class="keyword">true</span>,</span><br><span class="line">                screenShotContentObserver</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getContentResolver().unregisterContentObserver(screenShotContentObserver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getContentResolver().unregisterContentObserver(screenShotContentObserver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-如何截屏"><a href="#三-如何截屏" class="headerlink" title="三. 如何截屏"></a>三. 如何截屏</h2><h3 id="常见截屏方式"><a href="#常见截屏方式" class="headerlink" title="常见截屏方式"></a>常见截屏方式</h3><blockquote><p>1.获取当前Window的DrawingCache的方式，即DecorView的DrawingCache</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * shot the current screen ,with the status but the status is trans *</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> ctx current activity</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">shotActivity</span><span class="params">(Activity ctx)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    View view = ctx.getWindow().getDecorView();</span><br><span class="line">    view.setDrawingCacheEnabled(<span class="keyword">true</span>);</span><br><span class="line">    view.buildDrawingCache();</span><br><span class="line"></span><br><span class="line">    Bitmap bp = Bitmap.createBitmap(view.getDrawingCache(), <span class="number">0</span>, <span class="number">0</span>, view.getMeasuredWidth(),</span><br><span class="line">        view.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">    view.setDrawingCacheEnabled(<span class="keyword">false</span>);</span><br><span class="line">    view.destroyDrawingCache();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>获取某个View的DrawingCache</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">getViewBp</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == v) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v.setDrawingCacheEnabled(<span class="keyword">true</span>);</span><br><span class="line">        v.buildDrawingCache();</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">11</span>) &#123;</span><br><span class="line">            v.measure(MeasureSpec.makeMeasureSpec(v.getWidth(),</span><br><span class="line">                    MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(</span><br><span class="line">                    v.getHeight(), MeasureSpec.EXACTLY));</span><br><span class="line">            v.layout((<span class="keyword">int</span>) v.getX(), (<span class="keyword">int</span>) v.getY(),</span><br><span class="line">                    (<span class="keyword">int</span>) v.getX() + v.getMeasuredWidth(),</span><br><span class="line">                    (<span class="keyword">int</span>) v.getY() + v.getMeasuredHeight());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            v.measure(MeasureSpec.makeMeasureSpec(<span class="number">0</span>, MeasureSpec.UNSPECIFIED),</span><br><span class="line">                    MeasureSpec.makeMeasureSpec(<span class="number">0</span>, MeasureSpec.UNSPECIFIED));</span><br><span class="line">            v.layout(<span class="number">0</span>, <span class="number">0</span>, v.getMeasuredWidth(), v.getMeasuredHeight());</span><br><span class="line">        &#125;</span><br><span class="line">        Bitmap b = Bitmap.createBitmap(v.getDrawingCache(), <span class="number">0</span>, <span class="number">0</span>, v.getMeasuredWidth(), v.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">        v.setDrawingCacheEnabled(<span class="keyword">false</span>);</span><br><span class="line">        v.destroyDrawingCache();</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="使用三方Library"><a href="#使用三方Library" class="headerlink" title="使用三方Library"></a>使用三方Library</h3><blockquote><p><a href="https://github.com/tarek360/Instacapture" target="_blank" rel="noopener">tarek360.Instacapture</a>,使用Kotlin/Java实现的一个三方库，可以针对常见的View和一般视图实现快速截图。可以截图的包括：</p><ol><li>Google Map</li><li>Dialog,context menus,toasts</li><li>TextureView</li><li>GLSurfaceView</li></ol><p>并且可以设置非截图View，无权限要求。</p></blockquote><h3 id="ScrollView截屏"><a href="#ScrollView截屏" class="headerlink" title="ScrollView截屏"></a>ScrollView截屏</h3><blockquote><p>由于ScrollView只有一个直接子View，可以按照如下方式获取，<a href="https://stackoverflow.com/questions/43817116/take-a-full-screenshot-of-scrollview-android" target="_blank" rel="noopener">原链</a>:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmap = getBitmapFromView(scrollview, scrollview.getChildAt(<span class="number">0</span>).getHeight(), scrollview.getChildAt(<span class="number">0</span>).getWidth());</span><br><span class="line"></span><br><span class="line"><span class="comment">//create bitmap from the ScrollView </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Bitmap <span class="title">getBitmapFromView</span><span class="params">(View view, <span class="keyword">int</span> height, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">    Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);</span><br><span class="line">    Canvas canvas = <span class="keyword">new</span> Canvas(bitmap);</span><br><span class="line">    Drawable bgDrawable = view.getBackground();</span><br><span class="line">    <span class="keyword">if</span> (bgDrawable != <span class="keyword">null</span>)</span><br><span class="line">        bgDrawable.draw(canvas);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        canvas.drawColor(Color.WHITE);</span><br><span class="line">    view.draw(canvas);</span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><blockquote><p>ListView中存在的问题，条目过多，有很多未可见<a href="http://stackoverflow.com/questions/12742343/android-get-screenshot-of-all-listview-items" target="_blank" rel="noopener">原链</a>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">getWholeListViewItemsToBitmap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ListView listview    = MyActivity.mFocusedListView;</span><br><span class="line">    ListAdapter adapter  = listview.getAdapter(); </span><br><span class="line">    <span class="keyword">int</span> itemscount       = adapter.getCount();</span><br><span class="line">    <span class="keyword">int</span> allitemsheight   = <span class="number">0</span>;</span><br><span class="line">    List&lt;Bitmap&gt; bmps    = <span class="keyword">new</span> ArrayList&lt;Bitmap&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; itemscount; i++) &#123;</span><br><span class="line"></span><br><span class="line">        View childView      = adapter.getView(i, <span class="keyword">null</span>, listview);</span><br><span class="line">        childView.measure(MeasureSpec.makeMeasureSpec(listview.getWidth(), MeasureSpec.EXACTLY), </span><br><span class="line">                MeasureSpec.makeMeasureSpec(<span class="number">0</span>, MeasureSpec.UNSPECIFIED));</span><br><span class="line"></span><br><span class="line">        childView.layout(<span class="number">0</span>, <span class="number">0</span>, childView.getMeasuredWidth(), childView.getMeasuredHeight());</span><br><span class="line">        childView.setDrawingCacheEnabled(<span class="keyword">true</span>);</span><br><span class="line">        childView.buildDrawingCache();</span><br><span class="line">        bmps.add(childView.getDrawingCache());</span><br><span class="line">        allitemsheight+=childView.getMeasuredHeight();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Bitmap bigbitmap    = Bitmap.createBitmap(listview.getMeasuredWidth(), allitemsheight, Bitmap.Config.ARGB_8888);</span><br><span class="line">    Canvas bigcanvas    = <span class="keyword">new</span> Canvas(bigbitmap);</span><br><span class="line"></span><br><span class="line">    Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">    <span class="keyword">int</span> iHeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bmps.size(); i++) &#123;</span><br><span class="line">        Bitmap bmp = bmps.get(i);</span><br><span class="line">        bigcanvas.drawBitmap(bmp, <span class="number">0</span>, iHeight, paint);</span><br><span class="line">        iHeight+=bmp.getHeight();</span><br><span class="line"></span><br><span class="line">        bmp.recycle();</span><br><span class="line">        bmp=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bigbitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h3><blockquote><p>ListView的替代品RecyclerView,<a href="https://stackoverflow.com/questions/30085063/take-a-screenshot-of-recyclerview-in-full-length" target="_blank" rel="noopener">原链</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">getScreenshotFromRecyclerView</span><span class="params">(RecyclerView view)</span> </span>&#123;</span><br><span class="line">        RecyclerView.Adapter adapter = view.getAdapter();</span><br><span class="line">        Bitmap bigBitmap = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = adapter.getItemCount();</span><br><span class="line">            <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">            Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">            <span class="keyword">int</span> iHeight = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Use 1/8th of the available memory for this memory cache.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> cacheSize = maxMemory / <span class="number">8</span>;</span><br><span class="line">            LruCache&lt;String, Bitmap&gt; bitmaCache = <span class="keyword">new</span> LruCache&lt;&gt;(cacheSize);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                RecyclerView.ViewHolder holder = adapter.createViewHolder(view, adapter.getItemViewType(i));</span><br><span class="line">                adapter.onBindViewHolder(holder, i);</span><br><span class="line">                holder.itemView.measure(View.MeasureSpec.makeMeasureSpec(view.getWidth(), View.MeasureSpec.EXACTLY),</span><br><span class="line">                        View.MeasureSpec.makeMeasureSpec(<span class="number">0</span>, View.MeasureSpec.UNSPECIFIED));</span><br><span class="line">                holder.itemView.layout(<span class="number">0</span>, <span class="number">0</span>, holder.itemView.getMeasuredWidth(), holder.itemView.getMeasuredHeight());</span><br><span class="line">                holder.itemView.setDrawingCacheEnabled(<span class="keyword">true</span>);</span><br><span class="line">                holder.itemView.buildDrawingCache();</span><br><span class="line">                Bitmap drawingCache = holder.itemView.getDrawingCache();</span><br><span class="line">                <span class="keyword">if</span> (drawingCache != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    bitmaCache.put(String.valueOf(i), drawingCache);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                holder.itemView.setDrawingCacheEnabled(false);</span></span><br><span class="line"><span class="comment">//                holder.itemView.destroyDrawingCache();</span></span><br><span class="line">                height += holder.itemView.getMeasuredHeight();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bigBitmap = Bitmap.createBitmap(view.getMeasuredWidth(), height, Bitmap.Config.ARGB_8888);</span><br><span class="line">            Canvas bigCanvas = <span class="keyword">new</span> Canvas(bigBitmap);</span><br><span class="line">            bigCanvas.drawColor(Color.WHITE);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Bitmap bitmap = bitmaCache.get(String.valueOf(i));</span><br><span class="line">                bigCanvas.drawBitmap(bitmap, <span class="number">0f</span>, iHeight, paint);</span><br><span class="line">                iHeight += bitmap.getHeight();</span><br><span class="line">                bitmap.recycle();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bigBitmap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h3><blockquote><p><a href="https://stackoverflow.com/questions/9745988/how-can-i-programmatically-take-a-screenshot-of-a-webview-capturing-the-full-pa" target="_blank" rel="noopener">原链</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">w = <span class="keyword">new</span> WebView(<span class="keyword">this</span>);</span><br><span class="line">    w.setWebViewClient(<span class="keyword">new</span> WebViewClient()</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageFinished</span><span class="params">(WebView view, String url)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                    Picture picture = view.capturePicture();</span><br><span class="line">                    Bitmap  b = Bitmap.createBitmap( picture.getWidth(),</span><br><span class="line">                    picture.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">                    Canvas c = <span class="keyword">new</span> Canvas( b );</span><br><span class="line"></span><br><span class="line">                    picture.draw( c );</span><br><span class="line">                    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        fos = <span class="keyword">new</span> FileOutputStream( <span class="string">"mnt/sdcard/yahoo.jpg"</span> );</span><br><span class="line">                            <span class="keyword">if</span> ( fos != <span class="keyword">null</span> )</span><br><span class="line">                            &#123;</span><br><span class="line">                                b.compress(Bitmap.CompressFormat.JPEG, <span class="number">100</span>, fos);</span><br><span class="line"></span><br><span class="line">                                fos.close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                   <span class="keyword">catch</span>( Exception e )</span><br><span class="line">                   &#123;</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-Android如何禁止Application截屏？&quot;&gt;&lt;a href=&quot;#一-Android如何禁止Application截屏？&quot; class=&quot;headerlink&quot; title=&quot;一. Android如何禁止Application截屏？&quot;&gt;&lt;/a&gt;一. Android如何禁止Application截屏？&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;如果一遍不行，那就来两遍。&lt;a href=&quot;https://stackoverflow.com/questions/28606689/how-to-prevent-screen-capture-in-android&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FLAG_SECURE.StackOverflow&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java计算两个日期之间的天数</title>
    <link href="http://yoursite.com/2017/12/14/Java%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%97%A5%E6%9C%9F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A4%A9%E6%95%B0/"/>
    <id>http://yoursite.com/2017/12/14/Java计算两个日期之间的天数/</id>
    <published>2017-12-14T14:31:21.000Z</published>
    <updated>2017-12-17T12:30:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java中计算两个日期之间的天数-比如说2017-12-06与2017-12-04之间的天数差为2"><a href="#Java中计算两个日期之间的天数-比如说2017-12-06与2017-12-04之间的天数差为2" class="headerlink" title="Java中计算两个日期之间的天数,比如说2017/12/06与2017/12/04之间的天数差为2"></a>Java中计算两个日期之间的天数,比如说<strong>2017/12/06</strong>与<strong>2017/12/04</strong>之间的天数差为2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get a diff between two dates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> oldDate</span></span><br><span class="line"><span class="comment"> *            the old date</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newDate</span></span><br><span class="line"><span class="comment"> *            the new date</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the diff value, in the days</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getDateDiff</span><span class="params">(SimpleDateFormat format, String oldDate, String newDate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> TimeUnit.DAYS.convert(</span><br><span class="line">format.parse(newDate).getTime() - format.parse(oldDate).getTime(),</span><br><span class="line">TimeUnit.MILLISECONDS);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a> <h4 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"dd/MM/yyyy"</span>);</span><br><span class="line"><span class="keyword">long</span> dateDiff = getDateDiff(sdf, <span class="string">"4/12/2017"</span>, <span class="string">"6/12/2017"</span>);</span><br><span class="line">System.out.println(<span class="string">" days diff is : "</span> + dateDiff);</span><br></pre></td></tr></table></figure><h4 id="控制台将输出"><a href="#控制台将输出" class="headerlink" title="控制台将输出:"></a>控制台将输出:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">days diff is : 2</span><br></pre></td></tr></table></figure><p>参考<a href="https://stackoverflow.com/questions/21285161/android-difference-between-two-dates" target="_blank" rel="noopener">link</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Java中计算两个日期之间的天数-比如说2017-12-06与2017-12-04之间的天数差为2&quot;&gt;&lt;a href=&quot;#Java中计算两个日期之间的天数-比如说2017-12-06与2017-12-04之间的天数差为2&quot; class=&quot;headerlink&quot; title=&quot;Java中计算两个日期之间的天数,比如说2017/12/06与2017/12/04之间的天数差为2&quot;&gt;&lt;/a&gt;Java中计算两个日期之间的天数,比如说&lt;strong&gt;2017/12/06&lt;/strong&gt;与&lt;strong&gt;2017/12/04&lt;/strong&gt;之间的天数差为2&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Get a diff between two dates&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; oldDate&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *            the old date&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; newDate&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *            the new date&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; the diff value, in the days&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getDateDiff&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(SimpleDateFormat format, String oldDate, String newDate)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; TimeUnit.DAYS.convert(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			format.parse(newDate).getTime() - format.parse(oldDate).getTime(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			TimeUnit.MILLISECONDS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Android/Java/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>禁止WebView长按复制</title>
    <link href="http://yoursite.com/2017/12/13/%E7%A6%81%E6%AD%A2WebView%E9%95%BF%E6%8C%89%E5%A4%8D%E5%88%B6/"/>
    <id>http://yoursite.com/2017/12/13/禁止WebView长按复制/</id>
    <published>2017-12-13T15:37:03.000Z</published>
    <updated>2017-12-14T14:56:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Android-WebView安全相关，禁止长按复制"><a href="#Android-WebView安全相关，禁止长按复制" class="headerlink" title="Android WebView安全相关，禁止长按复制"></a>Android WebView安全相关，禁止长按复制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 通过消费WebView的长按事件来禁止复制 */</span></span><br><span class="line">webview.setOnLongClickListener(<span class="keyword">new</span> View.OnLongClickListener() &#123;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onLongClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Android-WebView安全相关，禁止长按复制&quot;&gt;&lt;a href=&quot;#Android-WebView安全相关，禁止长按复制&quot; class=&quot;headerlink&quot; title=&quot;Android WebView安全相关，禁止长按复制&quot;&gt;&lt;/a&gt;Android 
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="WebView" scheme="http://yoursite.com/categories/Android/WebView/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="WebView" scheme="http://yoursite.com/tags/WebView/"/>
    
  </entry>
  
  <entry>
    <title>如何使用HEXO创建博客</title>
    <link href="http://yoursite.com/2017/12/12/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8HEXO%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2017/12/12/如何使用HEXO创建博客/</id>
    <published>2017-12-12T15:37:03.000Z</published>
    <updated>2018-04-14T03:22:20.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、快速开始"><a href="#一、快速开始" class="headerlink" title="一、快速开始"></a>一、快速开始</h3><blockquote><p>Create a new post</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><blockquote><p>Run server</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><blockquote><p>Generate static files</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><blockquote><p>Deploy to remote sites</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><a id="more"></a> <p>More Info:</p><ul><li><a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></li><li><a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></li><li><a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></li><li><a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></li></ul><h3 id="二、设置自动滚动"><a href="#二、设置自动滚动" class="headerlink" title="二、设置自动滚动"></a>二、设置自动滚动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Automatically saving scroll position on each post/page in cookies.</span></span><br><span class="line">save_scroll: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="三、设置多个tag或category"><a href="#三、设置多个tag或category" class="headerlink" title="三、设置多个tag或category"></a>三、设置多个tag或category</h3><blockquote><p>伪JavaScript数组写法</p><p>tag: <code>[Hexo,HTML,JavaScript]</code><br>categories: <code>[Hexo,HTML]</code></p></blockquote><h3 id="四、关于Hexo-next主题如何在首页隐藏指定的文章"><a href="#四、关于Hexo-next主题如何在首页隐藏指定的文章" class="headerlink" title="四、关于Hexo next主题如何在首页隐藏指定的文章"></a>四、关于Hexo next主题如何在首页隐藏指定的文章</h3><!-- http://forwardkth.github.io/2016/05/08/next-theme-post-visibility/ --><blockquote><p>修改next主题文件夹下的layout中的index.swig文件，\themes\next\layout\index.swig</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/74505a4cgw1f3onp6eculj20ds0d70vb.jpg" alt="图示"></p><blockquote><p>在新的post中添加visible字段来控制是否首页显示</p><p>title: 关于Hexo next主题如何在首页隐藏指定的文章<br>visible: hide 这里如果加上hide则该文章就不会在文章首页显示，如果留空则表示默认显示</p></blockquote><h3 id="五、HEXO电脑切换"><a href="#五、HEXO电脑切换" class="headerlink" title="五、HEXO电脑切换"></a>五、HEXO电脑切换</h3><blockquote><p>创建hexo分支保存源码，如文中 <a href="https://blog.csdn.net/wxl1555/article/details/79293159" target="_blank" rel="noopener">https://blog.csdn.net/wxl1555/article/details/79293159</a><br>知乎大神，<a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">https://www.zhihu.com/question/21193762</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、快速开始&quot;&gt;&lt;a href=&quot;#一、快速开始&quot; class=&quot;headerlink&quot; title=&quot;一、快速开始&quot;&gt;&lt;/a&gt;一、快速开始&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Create a new post&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;Run server&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;Generate static files&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;Deploy to remote sites&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
      <category term="tools" scheme="http://yoursite.com/categories/Hexo/tools/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
